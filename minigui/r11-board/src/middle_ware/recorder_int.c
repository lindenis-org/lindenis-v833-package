#include <math.h>#include <stdbool.h>#include <unistd.h>#include <stdlib.h>#include <stdio.h>#include <string.h>#include <pthread.h>#include <ctype.h>#include <errno.h>#include <sys/stat.h> #include <sys/time.h>#include <sys/types.h>#include <time.h>#include <fcntl.h>#include <dirent.h>#include <sys/statfs.h>#include <sys/stat.h>#include "recorder_int.h"#include "common.h"#include "rec_list.h"#define FILE_POSTFIX_NAME  ".mov"//#define FILE_POSTFIX_NAME  ".ts"static unsigned char collide_f00 = 0;  //记录前一个文件是否需要保存static unsigned char collide_f01 = 0;  //记录当前文件是否需要保存static unsigned char collide_f02 = 0;  //记录下一个文件是否需要保存static unsigned char collide_f10 = 0;  //记录前一个文件是否需要保存static unsigned char collide_f11 = 0;  //记录当前文件是否需要保存static unsigned char collide_f12 = 0;  //记录下一个文件是否需要保存static unsigned char cur_collide_f0 = 0; //记录当前正在录制文件是否为保存文件static unsigned char cur_collide_f1 = 0; //记录当前正在录制文件是否为保存文件static unsigned char pre_collide_f0 = 0; static unsigned char pre_collide_f1 = 0;static unsigned char first_file_f0 = 0; static unsigned char first_file_f1 = 0;#define _GNU_SOURCE#include <fcntl.h>  #define FALLOC_FL_KEEP_SIZE	0x01 /* default is extend size */#define RESERVED_SPACE (300*1024*1024)#define REC_LIST_LEN_MAX 150#define	WM_POS_X_F		(180)#define	WM_POS_Y_F		(156)#define	WM_POS_X_B		(180)#define	WM_POS_Y_B		(128)static struct timeval time0; //记录第一路录像时间static struct timeval time1; //记录第二路录像时间static __dv_core_t  *dv_core;static list_node_t *rec_list_A = NULL;static list_node_t *rec_list_B = NULL;//按名称顺序int add_name_to_list(list_node_t * list, char *name){	list_node_t *tmp_list = NULL;	list_node_t *tmp_list1 = list;	list_node_t *new_node = NULL;	tmp_list = list->next;	while(tmp_list){		if(strcmp(tmp_list->filename, name) > 0){			break;		}		tmp_list1 = tmp_list;		tmp_list = tmp_list->next;	}	new_node = (list_node_t *)malloc(sizeof(list_node_t)); 	if(NULL==new_node)		return -1;	memset(new_node, 0, sizeof(list_node_t));	strcpy(new_node->filename, name);	tmp_list1->next = new_node;	new_node->next = tmp_list;	return 0;}// 核心：创建文件后马上fallocateint CreateMyFile(char * szFileName, int nFileLength){	int res,fd;  	fd = open(szFileName, O_RDWR | O_CREAT, 0666);	if (fd < 0) {		fprintf(stderr, "%s\n", strerror(errno));		close(fd);		return -1;	}	printf("fallocate start!\n");	if (res = fallocate(fd, FALLOC_FL_KEEP_SIZE, (off_t)0, (off_t)nFileLength)) {		fprintf(stderr, "%s\n", strerror(errno));		close(fd);		return -2;	}	fsync(fd);	close(fd);  	return 0;}////创建文件，文件名选择时间，并维护链表   postfix//后缀名int create_new_file(int index, long size, list_node_t *list, char *postfix, char *compete_path){	time_t timep;	struct tm *p;	time(&timep);	char name[32];	p = localtime(&timep); /*取得当地时间*/	//printf("%d-%02d-%02d ", (1900+p->tm_year),(1 + p->tm_mon), p->tm_mday);	//printf("%d:%d:%d\n", p->tm_hour, p->tm_min, p->tm_sec);	memset(name, 0, sizeof(name));	if(index == 0){		sprintf(name, "AW_%d%02d%02d_%02d%02d%02dA%s", (1900 + p->tm_year), \			(1 + p->tm_mon), p->tm_mday, p->tm_hour, p->tm_min, p->tm_sec, postfix);		sprintf(compete_path, "%s/%s", PARTH_A, name);	}else{		sprintf(name, "AW_%d%02d%02d_%02d%02d%02dB%s", (1900 + p->tm_year), \			(1 + p->tm_mon), p->tm_mday, p->tm_hour, p->tm_min, p->tm_sec, postfix);		sprintf(compete_path, "%s/%s", PARTH_B, name);	}	//printf("%s\n", compete_path);	/////create_file////////	if((CreateMyFile(compete_path, size))<0){		return -1;	}	list_add(list, name);	return 0;	}int rename_new_file(int index, long size, list_node_t *list, char *postfix, char *compete_path){	list_node_t *new_node;	char name[32];	char old_compete_path[64];	time_t timep;	int fsize1 = 0;	int fsize2 = 0;	struct tm *p;	struct stat sta;	time(&timep);	int ret = 0;	p = localtime(&timep); /*取得当地时间*/	//printf("%d-%02d-%02d ", (1900+p->tm_year),(1 + p->tm_mon), p->tm_mday);	//printf("%d:%d:%d\n", p->tm_hour, p->tm_min, p->tm_sec);	memset(name, 0, sizeof(name));	memset(old_compete_path, 0, sizeof(old_compete_path));	new_node = list_del(list);	if(!new_node)		return -1;	if(index == 0){		sprintf(old_compete_path, "%s/%s", PARTH_A, new_node->filename);		sprintf(name, "AW_%d%02d%02d_%02d%02d%02dA%s", (1900 + p->tm_year), \			(1 + p->tm_mon), p->tm_mday, p->tm_hour, p->tm_min, p->tm_sec, postfix);		sprintf(compete_path, "%s/%s", PARTH_A, name);			}else{		sprintf(old_compete_path, "%s/%s", PARTH_B, new_node->filename);		sprintf(name, "AW_%d%02d%02d_%02d%02d%02dB%s", (1900 + p->tm_year), \			(1 + p->tm_mon), p->tm_mday, p->tm_hour, p->tm_min, p->tm_sec, postfix);		sprintf(compete_path, "%s/%s", PARTH_B, name);	}	free(new_node);	stat(old_compete_path, &sta);	//printf("st_blksize = %d, st_blocks = %d\n", sta.st_blksize, sta.st_blocks);	fsize1 = 512 * sta.st_blocks;	//printf("size = %ld\n", size);	//printf("fsize1 = %d\n", fsize1);	if(fsize1 >= size){		if((rename(old_compete_path, compete_path))<0){		fprintf(stderr, "%s \n", strerror(errno));		return -1;		}		printf("truncate64 function start!/n");		if (ret = truncate64(compete_path, 1)) {			fprintf(stderr, "%s \n", strerror(errno));					return -1;		}		list_add(list, name);	}else{		fsize2 += fsize1;		remove(old_compete_path);				while(fsize2 < size){			new_node = list_del(list);			if(!new_node)				return -1;			if(index == 0){				sprintf(old_compete_path, "%s/%s", PARTH_A, new_node->filename);				//sprintf(name, "AW_%d%02d%02d_%02d%02d%02dA%s", (1900 + p->tm_year), \				//	(1 + p->tm_mon), p->tm_mday, p->tm_hour, p->tm_min, p->tm_sec, postfix);				//sprintf(compete_path, "%s/%s", PARTH_A, name);							}else{				sprintf(old_compete_path, "%s/%s", PARTH_B, new_node->filename);				//sprintf(name, "AW_%d%02d%02d_%02d%02d%02dB%s", (1900 + p->tm_year), \				//	(1 + p->tm_mon), p->tm_mday, p->tm_hour, p->tm_min, p->tm_sec, postfix);				//sprintf(compete_path, "%s/%s", PARTH_B, name);			}			free(new_node);			stat(old_compete_path, &sta);			fsize1 = sta.st_blksize * sta.st_blocks;			fsize2 += fsize1;			remove(old_compete_path);		}		create_new_file(index, size, list, postfix, compete_path);			}	return 0;}int create_file(char *compete_path, int theth, int size, list_node_t *list, int index, char *postfix){	if(compete_path == NULL||list == NULL){		return -1;	}	printf("size = %d\n", size);    //如果有足够剩余空间	if(theth){		create_new_file(index, size, list, postfix, compete_path);	}    //如果无足够剩余空间	else{		rename_new_file(index, size, list, postfix, compete_path);	}		return 0;}int create_new_file_no_list(int index, long size, char *postfix, char *compete_path){	time_t timep;	struct tm *p;	time(&timep);	char name[32];	p = localtime(&timep); /*取得当地时间*/	printf("%d-%02d-%02d ", (1900+p->tm_year),(1 + p->tm_mon), p->tm_mday);	printf("%d:%d:%d\n", p->tm_hour, p->tm_min, p->tm_sec);	memset(name, 0, sizeof(name));	if(index == 0){		sprintf(name, "ZW_%d%02d%02d_%02d%02d%02dA%s", (1900 + p->tm_year), \			(1 + p->tm_mon), p->tm_mday, p->tm_hour, p->tm_min, p->tm_sec, postfix);		sprintf(compete_path, "%s/%s", PARTH_A, name);	}else{		sprintf(name, "ZW_%d%02d%02d_%02d%02d%02dB%s", (1900 + p->tm_year), \			(1 + p->tm_mon), p->tm_mday, p->tm_hour, p->tm_min, p->tm_sec, postfix);		sprintf(compete_path, "%s/%s", PARTH_B, name);	}	printf("%s\n", compete_path);	/////create_file////////	if((CreateMyFile(compete_path, size))<0){		return -1;	}	return 0;	}int rename_new_file_no_list(int index, long size, list_node_t *list, char *postfix, char *compete_path){	list_node_t *new_node;	char name[32];	char old_compete_path[64];	time_t timep;	int fsize1 = 0;	int fsize2 = 0;	struct tm *p;	struct stat sta;	time(&timep);	int ret = 0;	p = localtime(&timep); /*取得当地时间*/	printf("%d-%02d-%02d ", (1900+p->tm_year),(1 + p->tm_mon), p->tm_mday);	printf("%d:%d:%d\n", p->tm_hour, p->tm_min, p->tm_sec);	memset(name, 0, sizeof(name));	memset(old_compete_path, 0, sizeof(old_compete_path));	new_node = list_del(list);	if(!new_node)		return -1;	if(index == 0){		sprintf(old_compete_path, "%s/%s", PARTH_A, new_node->filename);		sprintf(name, "ZW_%d%02d%02d_%02d%02d%02dA%s", (1900 + p->tm_year), \			(1 + p->tm_mon), p->tm_mday, p->tm_hour, p->tm_min, p->tm_sec, postfix);		sprintf(compete_path, "%s/%s", PARTH_A, name);			}else{		sprintf(old_compete_path, "%s/%s", PARTH_B, new_node->filename);		sprintf(name, "ZW_%d%02d%02d_%02d%02d%02dB%s", (1900 + p->tm_year), \			(1 + p->tm_mon), p->tm_mday, p->tm_hour, p->tm_min, p->tm_sec, postfix);		sprintf(compete_path, "%s/%s", PARTH_B, name);	}	free(new_node);	stat(old_compete_path, &sta);	//printf("st_blksize = %d, st_blocks = %d\n", sta.st_blksize, sta.st_blocks);	fsize1 = 512 * sta.st_blocks;	//printf("size = %ld\n", size);	//printf("fsize1 = %d\n", fsize1);	if(fsize1 >= size){		if((rename(old_compete_path, compete_path))<0){		fprintf(stderr, "%s \n", strerror(errno));		return -1;		}		printf("truncate64 function start!/n");		if (ret = truncate64(compete_path, 1)) {			fprintf(stderr, "%s \n", strerror(errno));					return -1;		}	}else{		fsize2 += fsize1;		remove(old_compete_path);				while(fsize2 < size){			new_node = list_del(list);			if(!new_node)				return -1;			if(index == 0){				sprintf(old_compete_path, "%s/%s", PARTH_A, new_node->filename);			}else{				sprintf(old_compete_path, "%s/%s", PARTH_B, new_node->filename);			}			free(new_node);			stat(old_compete_path, &sta);			fsize1 = sta.st_blksize * sta.st_blocks;			fsize2 += fsize1;			remove(old_compete_path);		}		create_new_file_no_list(index, size, postfix, compete_path);			}	return 0;}int create_file_no_list(char *compete_path, int theth, list_node_t *list,int size, int index, char *postfix){	if(compete_path == NULL){		return -1;	}    //如果有足够剩余空间	if(theth){		create_new_file_no_list(index, size, postfix, compete_path);	}    //如果无足够剩余空间	else{		rename_new_file_no_list(index, size, list, postfix, compete_path);	}		return 0;}int rename_pre_file(list_node_t *head, int index){	int i = 0;	list_node_t *tmp_node;	char compete_path[64];	char old_compete_path[64];		i = list_get_total(head);	if(i < 2){		return -1;	}		i -= 1;	tmp_node = list_del_index(head, i);	memset(compete_path, 0, sizeof(compete_path));	if(index == 0){		sprintf(old_compete_path, "%s/%s", PARTH_A, tmp_node->filename);		tmp_node->filename[0] = 'Z';		sprintf(compete_path, "%s/%s", PARTH_A, tmp_node->filename);	}else{		sprintf(old_compete_path, "%s/%s", PARTH_B, tmp_node->filename);		tmp_node->filename[0] = 'Z';		sprintf(compete_path, "%s/%s", PARTH_B, tmp_node->filename);	}	if((rename(old_compete_path, compete_path))<0){		fprintf(stderr, "%s \n", strerror(errno));		return -1;	}	free(tmp_node);	return 0;}int rename_cur_file(list_node_t *head, int index){	int i = 0;	list_node_t *tmp_node;	char compete_path[64];	char old_compete_path[64];		i = list_get_total(head);	if(i < 1){		return -1;	}		tmp_node = list_del_index(head, i);	memset(compete_path, 0, sizeof(compete_path));	if(index == 0){		sprintf(old_compete_path, "%s/%s", PARTH_A, tmp_node->filename);		tmp_node->filename[0] = 'Z';		sprintf(compete_path, "%s/%s", PARTH_A, tmp_node->filename);	}else{		sprintf(old_compete_path, "%s/%s", PARTH_B, tmp_node->filename);		tmp_node->filename[0] = 'Z';		sprintf(compete_path, "%s/%s", PARTH_B, tmp_node->filename);	}	if((rename(old_compete_path, compete_path))<0){		fprintf(stderr, "%s \n", strerror(errno));		return -1;	}	free(tmp_node);	return 0;}//判断是否是特殊目录static int is_special_dir(const char *path){	    return strcmp(path, ".") == 0 || strcmp(path, "..") == 0;}list_node_t * create_list_by_path(char *path){	DIR *dir;	int status; 	list_node_t *list;	struct dirent *dir_info;	if((dir = opendir(path)) == NULL){		printf("%s is not exist.\n", path);			status = mkdir(path, S_IRWXU | S_IRWXG | S_IRWXO);		if(status < 0){			printf("mkdir failed %s.\n", path);			return NULL;		}		list = create_list();		return list;	}	list = create_list();	while((dir_info = readdir(dir)) != NULL){		// 忽略文件.和..		if(is_special_dir(dir_info->d_name))				continue;            // 根据文件名管理现有文件，把现有文件插入链表            // 文件名结构：aw_20170101_905023A.mp4/ts            if(strcmp(dir_info->d_name+strlen(dir_info->d_name)-strlen(FILE_POSTFIX_NAME), FILE_POSTFIX_NAME) == 0 \			  && strncmp(dir_info->d_name, "AW_", 3) == 0) {			add_name_to_list(list, dir_info->d_name);			}	}	closedir(dir);//关闭目录	return list;}static void __dv_get_record_size(__dv_core_t  *dv_core, int index){	switch(dv_core->rec_quality_mode[index]){	case RECORD_QUALITY_640_480:			dv_core->rec_size[index].width = 640;		dv_core->rec_size[index].height = 480;		dv_core->video_bps[index] = 1*1000*1000;		//dv_core->frame_rate[index] = 25;		break;	case RECORD_QUALITY_1280_720:			dv_core->rec_size[index].width = 1280;		dv_core->rec_size[index].height = 720;		dv_core->video_bps[index] = 6*1000*1000;		//dv_core->frame_rate[index] = 30;		break;	case RECORD_QUALITY_1920_1080:			dv_core->rec_size[index].width = 1920;		dv_core->rec_size[index].height = 1080;		dv_core->video_bps[index] = 8*1000*1000;		//dv_core->frame_rate[index] = 25;		break;	default:		dv_core->rec_size[index].width = 1280;		dv_core->rec_size[index].height = 720;		dv_core->video_bps[index] = 3*1000*1000;		//dv_core->frame_rate[index] = 30;		break;	}}static void __dv_get_camera_size(__dv_core_t  *dv_core, int index){    switch(dv_core->cam_quality_mode[index]){    case CAMERA_QUALITY_100:           dv_core->cam_size[index].width = 1280;        dv_core->cam_size[index].height = 960;        break;    case CAMERA_QUALITY_200:        dv_core->cam_size[index].width = 1600;        dv_core->cam_size[index].height = 1200;        break;    case CAMERA_QUALITY_300:        dv_core->cam_size[index].width = 2048;        dv_core->cam_size[index].height = 1536;        break;    case CAMERA_QUALITY_500:        dv_core->cam_size[index].width = 2560;        dv_core->cam_size[index].height = 1920;        break;    case CAMERA_QUALITY_800:        dv_core->cam_size[index].width = 3264;        dv_core->cam_size[index].height = 2448;        break;    default:        dv_core->cam_size[index].width = 1600;        dv_core->cam_size[index].height = 1200;        break;    }}static void __dv_get_cycle_rec_time(__dv_core_t  *dv_core, int index){	switch(dv_core->cycle_rec_time[index]){	case CYCLE_REC_TIME_1_MIM:		dv_core->rec_time_ms[index] = 60*1000;		break;	case CYCLE_REC_TIME_2_MIM:		dv_core->rec_time_ms[index] = 2*60*1000;		break;	case CYCLE_REC_TIME_3_MIM:		dv_core->rec_time_ms[index] = 3*60*1000;		break;	case CYCLE_REC_TIME_5_MIM:		dv_core->rec_time_ms[index] = 5*60*1000;		break;	default:		dv_core->rec_time_ms[index] = 2*60*1000;		break;	}}int CallbackFromTRecorder0(void* pUserData, int msg, void* param){    __dv_core_t  *dv_core = ( __dv_core_t  *)pUserData;	char parth[128];	int theth = 1;		int f_size = 0; 	memset(parth, 0, sizeof(parth));    switch(msg){    case T_RECORD_ONE_FILE_COMPLETE:        printf("T_RECORD_ONE_FILE_COMPLETE 0\n");		memset(parth, 0, sizeof(parth));		f_size = ((dv_core->video_bps[0]+1000000)/1000/1000)*1024*1024/8*(dv_core->rec_time_ms[0]/1000);		if(get_disk_free() < ((RESERVED_SPACE + f_size)>>10) || list_get_total(rec_list_A) >= REC_LIST_LEN_MAX){			theth = 0;		}else{			theth = 1;		}		pthread_mutex_lock(&dv_core->mutex0[0]);		if(first_file_f0 < 2)			first_file_f0++;		//碰撞保存		if(collide_f00 == 1){			rename_pre_file(rec_list_A, 0);			collide_f00 = 0;		}		if(collide_f01 == 1){			rename_cur_file(rec_list_A, 0);			collide_f01 = 0;		}		if(collide_f02 == 1){			create_file_no_list(parth, theth, rec_list_A, f_size, 0, FILE_POSTFIX_NAME);			collide_f02 = 0;			pre_collide_f0 = cur_collide_f0;			cur_collide_f0 = 1;		}else{			create_file(parth, theth, f_size, rec_list_A, 0, FILE_POSTFIX_NAME);			pre_collide_f0 = cur_collide_f0;			cur_collide_f0 = 0;		}		pthread_mutex_unlock(&dv_core->mutex0[0]);		TRchangeOutputPath(dv_core->mTrecorder[0],parth);		break;    default:        printf("warning: unknown callback from trecorder\n");        break;	}    return 0;}int CallbackFromTRecorder1(void* pUserData, int msg, void* param){    __dv_core_t  *dv_core = ( __dv_core_t  *)pUserData;	char parth[128];	int theth = 1;		int f_size = 0; 	memset(parth, 0, sizeof(parth));    switch(msg){    case T_RECORD_ONE_FILE_COMPLETE:        printf("T_RECORD_ONE_FILE_COMPLETE 1\n");		memset(parth, 0, sizeof(parth));		f_size = ((dv_core->video_bps[1]+1000000)/1000/1000)*1024*1024/8*(dv_core->rec_time_ms[1]/1000);		if(get_disk_free() < ((RESERVED_SPACE + f_size)>>10) || list_get_total(rec_list_B) >= REC_LIST_LEN_MAX){			theth = 0;		}else{			theth = 1;		}		pthread_mutex_lock(&dv_core->mutex0[1]);		if(first_file_f1 < 2)			first_file_f1++;		//碰撞保存		if(collide_f10 == 1){			rename_pre_file(rec_list_B, 1);			collide_f10 = 0;		}		if(collide_f11 == 1){			rename_cur_file(rec_list_B, 1);			collide_f11 = 0;		}		if(collide_f12 == 1){			create_file_no_list(parth, theth, rec_list_B, f_size, 1, FILE_POSTFIX_NAME);			collide_f12 = 0;			pre_collide_f1 = cur_collide_f1;			cur_collide_f1 = 1;		}else{			create_file(parth, theth, f_size, rec_list_B, 1, FILE_POSTFIX_NAME);			pre_collide_f1 = cur_collide_f1;			cur_collide_f1 = 0;		}		pthread_mutex_unlock(&dv_core->mutex0[1]);		TRchangeOutputPath(dv_core->mTrecorder[1],parth);	    break;    default:        printf("warning: unknown callback from trecorder\n");        break;	}    return 0;}int recorder_init(int index){	if(dv_core->record_sta[index] != RECORD_UNINIT){		return -1;	}	__dv_get_camera_size(dv_core, index);	__dv_get_record_size(dv_core, index);	__dv_get_cycle_rec_time(dv_core, index);	dv_core->mTrecorder[index] = CreateTRecorder();	if(dv_core->mTrecorder[index] == NULL){		printf("CreateTRecorder err0\n");		return -1;	}	TRreset(dv_core->mTrecorder[index]);	if(index == 0){		TRsetCamera(dv_core->mTrecorder[index],T_CAMERA_FRONT);		TRsetAudioSrc(dv_core->mTrecorder[index],T_AUDIO_MIC0);		TRsetPreview(dv_core->mTrecorder[index],T_DISP_LAYER0);		TRsetOutput(dv_core->mTrecorder[index],"/mnt/SDCARD/recorder_save0.mp4");		TRsetCameraEnableWM(dv_core->mTrecorder[index], WM_POS_X_F, WM_POS_Y_F, dv_core->time_water_en[index]);	}else{		TRsetCamera(dv_core->mTrecorder[index],T_CAMERA_BACK);		TRsetAudioSrc(dv_core->mTrecorder[index],T_AUDIO_MIC1);        TRsetPreview(dv_core->mTrecorder[index],T_DISP_LAYER1);		TRsetOutput(dv_core->mTrecorder[index],"/mnt/SDCARD/recorder_save1.mp4");		TRsetCameraEnableWM(dv_core->mTrecorder[index], WM_POS_X_B, WM_POS_Y_B, dv_core->time_water_en[index]);	}		TRsetOutputFormat(dv_core->mTrecorder[index],T_OUTPUT_MOV); // 设置封装格式	//TRsetOutputFormat(dv_core->mTrecorder[index],T_OUTPUT_TS); // 设置封装格式	TRsetVideoEncoderFormat(dv_core->mTrecorder[index],T_VIDEO_H264); //设置视频编码格式	TRsetAudioEncoderFormat(dv_core->mTrecorder[index],T_AUDIO_AAC); // 设置音频编码格式		TRsetMaxRecordTimeMs(dv_core->mTrecorder[index], dv_core->rec_time_ms[index]);	TRsetRecorderEnable(dv_core->mTrecorder[index],1);	TRsetEncoderBitRate(dv_core->mTrecorder[index], dv_core->video_bps[index]);	TRsetEncodeFramerate(dv_core->mTrecorder[index], dv_core->source_frate[index]);	TRsetVideoEncodeSize(dv_core->mTrecorder[index],dv_core->rec_size[index].width,dv_core->rec_size[index].height);	TRsetCameraEnable(dv_core->mTrecorder[index],1);	TRsetCameraInputFormat(dv_core->mTrecorder[index],T_CAMERA_YVU420SP);	TRsetCameraFramerate(dv_core->mTrecorder[index],dv_core->source_frate[index]);	TRsetCameraCaptureSize(dv_core->mTrecorder[index],dv_core->source_size[index].width, dv_core->source_size[index].height);	TRsetMICEnable(dv_core->mTrecorder[index],1);	TRsetMICInputFormat(dv_core->mTrecorder[index],T_MIC_PCM);	TRsetMICSampleRate(dv_core->mTrecorder[index],8000);	TRsetMICChannels(dv_core->mTrecorder[index],2);	TRsetAudioMute(dv_core->mTrecorder[index], dv_core->mute_en[index]);		if(index == 0)		TRsetRecorderCallback(dv_core->mTrecorder[index], CallbackFromTRecorder0,(void*)dv_core);	else		TRsetRecorderCallback(dv_core->mTrecorder[index], CallbackFromTRecorder1,(void*)dv_core);	if(dv_core->pre_mode[index] == PREVIEW_HOST){		if(index == 0){			TRsetPreviewRoute(dv_core->mTrecorder[index],T_ROUTE_VE);			//TRsetVEScaleDownRatio(dv_core->mTrecorder[index],2);			TRsetPreviewEnable(dv_core->mTrecorder[index],1);			TRsetPreviewRotate(dv_core->mTrecorder[index],T_ROTATION_ANGLE_0);			TRsetVEScaleDownRatio(dv_core->mTrecorder[index],2);		}else{			TRsetPreviewRoute(dv_core->mTrecorder[index],T_ROUTE_CAMERA);			TRsetPreviewEnable(dv_core->mTrecorder[index],1);			TRsetPreviewRotate(dv_core->mTrecorder[index],T_ROTATION_ANGLE_0);		}				TRsetPreviewRect(dv_core->mTrecorder[index],&dv_core->show_rect);		TRsetPreviewZorder(dv_core->mTrecorder[index], T_PREVIEW_ZORDER_BOTTOM);			}else{		if(index == 0){			TRsetPreviewRoute(dv_core->mTrecorder[index],T_ROUTE_VE);			//TRsetVEScaleDownRatio(dv_core->mTrecorder[index],4);			TRsetPreviewEnable(dv_core->mTrecorder[index],1);			TRsetPreviewRotate(dv_core->mTrecorder[index],T_ROTATION_ANGLE_0);			TRsetVEScaleDownRatio(dv_core->mTrecorder[index],4);		}else{			TRsetPreviewRoute(dv_core->mTrecorder[index],T_ROUTE_CAMERA);			TRsetPreviewEnable(dv_core->mTrecorder[index],1);			TRsetPreviewRotate(dv_core->mTrecorder[index],T_ROTATION_ANGLE_0);		}				TRsetPreviewRect(dv_core->mTrecorder[index],&dv_core->pip_rect);		TRsetPreviewZorder(dv_core->mTrecorder[index], T_PREVIEW_ZORDER_MIDDLE);	}		TRprepare(dv_core->mTrecorder[index]);	dv_core->record_sta[index] = RECORD_STOP;	return 0;}int recorder_exit(int index){	int i = 0;	if(dv_core->record_sta[index] == RECORD_UNINIT){		return -1;	}	TRsetPreviewEnable(dv_core->mTrecorder[index],0);	TRstop(dv_core->mTrecorder[index], T_ALL);	TRrelease(dv_core->mTrecorder[index]);	dv_core->mTrecorder[index] = NULL;	dv_core->record_sta[index] = RECORD_UNINIT;	return 0;}int recorder_reserve_size(void){	int f_size0, f_size1;	f_size0 = ((dv_core->video_bps[0]+1000000)/1000/1000)*1024*1024/8*(dv_core->rec_time_ms[0]/1000);	f_size1 = ((dv_core->video_bps[1]+1000000)/1000/1000)*1024*1024/8*(dv_core->rec_time_ms[1]/1000);	return (f_size0+f_size1+RESERVED_SPACE+1024*1024)>>10;}//可删除文件是否够用。 1 够用 0 不够用-1 其他错误int recorder_ish_deleted_file(void){	int flag, i;	char compete_path[128];	list_node_t *tmp_node;	int tmp_size;	int f_size;	struct stat sta;	CHECK_NULL_POINTER(rec_list_A);	CHECK_NULL_POINTER(rec_list_B);	memset(compete_path, 0, sizeof(compete_path));	tmp_node = rec_list_A->next;	tmp_size = 0;	flag = 0;	f_size = ((dv_core->video_bps[0]+1000000)/1000/1000)*1024*1024/8*(dv_core->rec_time_ms[0]/1000);	while (tmp_node) {		sprintf(compete_path, "%s/%s", PARTH_A, tmp_node->filename);		stat(compete_path, &sta);		tmp_size += (512 * sta.st_blocks);		if(tmp_size > f_size){			flag = 1;			break;		}		tmp_node = tmp_node->next;	}	if(flag == 0){		return 0;	}	tmp_node = rec_list_B->next;	tmp_size = 0;	flag = 0;	f_size = ((dv_core->video_bps[1]+1000000)/1000/1000)*1024*1024/8*(dv_core->rec_time_ms[1]/1000);	while(tmp_node){		sprintf(compete_path, "%s/%s", PARTH_B, tmp_node->filename);		stat(compete_path, &sta);		tmp_size += (512 * sta.st_blocks);		if(tmp_size > f_size){			flag = 1;			break;		}		tmp_node = tmp_node->next;	}	if(flag == 0){		return 0;	}	return 1;}int recorder_start_preview(int index){	CHECK_NULL_POINTER(dv_core);	CHECK_NULL_POINTER(dv_core->mTrecorder[index]);		pthread_mutex_lock(&dv_core->mutex1[index]);	if(dv_core->record_sta[index] == RECORD_UNINIT){		printf("index %d is not init.\n", index);		pthread_mutex_unlock(&dv_core->mutex1[index]);		return -1;	}	pthread_mutex_unlock(&dv_core->mutex1[index]);	TRstart(dv_core->mTrecorder[index], T_PREVIEW);	return 0;}int recorder_stop_preview(int index){	CHECK_NULL_POINTER(dv_core);	CHECK_NULL_POINTER(dv_core->mTrecorder[index]);	pthread_mutex_lock(&dv_core->mutex1[index]);	if(dv_core->record_sta[index] == RECORD_UNINIT){		printf("index %d is not init.\n", index);		pthread_mutex_unlock(&dv_core->mutex1[index]);		return -1;	}	pthread_mutex_unlock(&dv_core->mutex1[index]);	TRstop(dv_core->mTrecorder[index], T_PREVIEW);	return 0;}//开关显示图层int recorder_preview_en(int index, bool onoff){	CHECK_NULL_POINTER(dv_core);	CHECK_NULL_POINTER(dv_core->mTrecorder[index]);	TRsetPreviewEnable(dv_core->mTrecorder[index],onoff);	return 0;}int recorder_set_preview_mode(int index, __preview_mode_e pre_mode){	dv_core->pre_mode[index] = pre_mode;	if(dv_core->pre_mode[index] == PREVIEW_HOST){		if(index == 0){			//TRsetVEScaleDownRatio(dv_core->mTrecorder[index],2);			TRsetPreviewRect(dv_core->mTrecorder[index],&dv_core->show_rect);			TRsetPreviewZorder(dv_core->mTrecorder[index], T_PREVIEW_ZORDER_BOTTOM);		}else{						TRsetPreviewRect(dv_core->mTrecorder[index],&dv_core->show_rect);			TRsetPreviewZorder(dv_core->mTrecorder[index], T_PREVIEW_ZORDER_BOTTOM);		}	}else{		if(index == 0){			//TRsetVEScaleDownRatio(dv_core->mTrecorder[index],4);			TRsetPreviewRect(dv_core->mTrecorder[index],&dv_core->pip_rect);			TRsetPreviewZorder(dv_core->mTrecorder[index], T_PREVIEW_ZORDER_MIDDLE);		}else{			TRsetPreviewRect(dv_core->mTrecorder[index],&dv_core->pip_rect);			TRsetPreviewZorder(dv_core->mTrecorder[index], T_PREVIEW_ZORDER_MIDDLE);		}	}}int recorder_start_recording(int index){	CHECK_NULL_POINTER(dv_core);	CHECK_NULL_POINTER(dv_core->mTrecorder[index]);	pthread_mutex_lock(&dv_core->mutex1[index]);	if(dv_core->record_sta[index] != RECORD_STOP){		printf("not prepared or stop state.\n");		pthread_mutex_unlock(&dv_core->mutex1[index]);		return -1;	}	pthread_mutex_unlock(&dv_core->mutex1[index]);	if(!rec_list_A || !rec_list_B){		printf("list is not create!\n");		pthread_mutex_unlock(&dv_core->mutex1[index]);		return -1;	}	if(index == 0){		collide_f00 = 0;		collide_f01 = 0;		collide_f02 = 0;		cur_collide_f0 = 0;		pre_collide_f0 = 0;		first_file_f0 = 0;	}else{		collide_f10 = 0;		collide_f11 = 0;		collide_f12 = 0;		cur_collide_f1 = 0;		pre_collide_f1 = 0;		first_file_f1 = 0;	}	//开始录像	TRstart(dv_core->mTrecorder[index], T_RECORD);	if(index == 0){  		gettimeofday(&time0, NULL);	}else{		gettimeofday(&time1, NULL);	}	pthread_mutex_lock(&dv_core->mutex1[index]);	dv_core->record_sta[index] = RECORD_START;	pthread_mutex_unlock(&dv_core->mutex1[index]);	return 0;}int recorder_stop_recording(int index){	CHECK_NULL_POINTER(dv_core);	CHECK_NULL_POINTER(dv_core->mTrecorder[index]);	pthread_mutex_lock(&dv_core->mutex1[index]);	if(dv_core->record_sta[index] != RECORD_START){		printf("record not start!\n");		pthread_mutex_unlock(&dv_core->mutex1[index]);		return -1;	}	pthread_mutex_unlock(&dv_core->mutex1[index]);	//停止录像	TRstop(dv_core->mTrecorder[index], T_RECORD);	//碰撞保存	if(index == 0){		if(collide_f00 == 1){			rename_pre_file(rec_list_A, 0);			collide_f00 = 0;		}		if(collide_f01 == 1){			rename_cur_file(rec_list_A, 0);			collide_f01 = 0;		}		cur_collide_f0 = 0;		pre_collide_f0 = 0;		first_file_f0 = 0;	}else{		if(collide_f10 == 1){			rename_pre_file(rec_list_B, 1);			collide_f10 = 0;		}		if(collide_f11 == 1){			rename_cur_file(rec_list_B, 1);			collide_f11 = 0;		}		cur_collide_f1 = 0;		pre_collide_f1 = 0;		first_file_f1 = 0;	}	pthread_mutex_lock(&dv_core->mutex1[index]);	dv_core->record_sta[index] = RECORD_STOP;	pthread_mutex_unlock(&dv_core->mutex1[index]);	return 0;}int recorder_take_picture(int index){	int status; 	DIR *dir;	TCaptureConfig config;	CHECK_NULL_POINTER(dv_core);	if((dir = opendir(PARTH_A)) == NULL){		printf("%s is not exist.\n", PARTH_A);			status = mkdir(PARTH_A, S_IRWXU | S_IRWXG | S_IRWXO);		if(status < 0){			printf("mkdir failed %s.\n", PARTH_A);			return -1;		}	}else{		closedir(dir);	}	if((dir = opendir(PARTH_B)) == NULL){		printf("%s is not exist.\n", PARTH_B);			status = mkdir(PARTH_B, S_IRWXU | S_IRWXG | S_IRWXO);		if(status < 0){			printf("mkdir failed %s.\n", PARTH_B);			return -1;		}	}else{		closedir(dir);	}	memset(&config, 0, sizeof(TCaptureConfig));	//检测是否为就绪状态	pthread_mutex_lock(&dv_core->mutex1[index]);	if(dv_core->record_sta[index] ==  RECORD_UNINIT){		printf("record not init!\n");		pthread_mutex_unlock(&dv_core->mutex1[index]);		return -1;	}	pthread_mutex_unlock(&dv_core->mutex1[index]);	time_t timep;	struct tm *p;	time(&timep);	p = localtime(&timep); /*取得当地时间*/	//printf("%d%d%d ", (1900+p->tm_year),(1 + p->tm_mon), p->tm_mday);	//printf("%d:%d:%d\n", p->tm_hour, p->tm_min, p->tm_sec);	if(index == 0)		sprintf(config.capturePath, "%s/AW_%d%02d%02d_%02d%02d%02dA.jpg", PARTH_A, (1900+p->tm_year),(1 + p->tm_mon), p->tm_mday, p->tm_hour, p->tm_min, p->tm_sec);	else		sprintf(config.capturePath, "%s/AW_%d%02d%02d_%02d%02d%02dB.jpg", PARTH_B, (1900+p->tm_year),(1 + p->tm_mon), p->tm_mday, p->tm_hour, p->tm_min, p->tm_sec);	config.captureFormat = T_CAPTURE_JPG;	config.captureWidth = dv_core->source_size[index].width;	config.captureHeight = dv_core->source_size[index].height;	TRCaptureCurrent(dv_core->mTrecorder[index], &config);	return 0;}int recorder_mute_en(int index, bool onoff){	CHECK_NULL_POINTER(dv_core);	CHECK_NULL_POINTER(dv_core->mTrecorder[index]);	//检测是否为就绪状态	pthread_mutex_lock(&dv_core->mutex1[index]);	if(dv_core->record_sta[index] ==  RECORD_UNINIT){		printf("record not init!\n");		pthread_mutex_unlock(&dv_core->mutex1[index]);		return -1;	}	pthread_mutex_unlock(&dv_core->mutex1[index]);	TRsetAudioMute(dv_core->mTrecorder[index], onoff);	return 0;}int recorder_get_rec_state(int index){	int ret;	CHECK_NULL_POINTER(dv_core);	pthread_mutex_lock(&dv_core->mutex1[index]);	ret =  dv_core->record_sta[index];	pthread_mutex_unlock(&dv_core->mutex1[index]);	return ret;}int recorder_get_cur_rectime(int index){	double diff;	unsigned long long t0;	unsigned int t1;	static struct timeval time2;	CHECK_NULL_POINTER(dv_core);	gettimeofday(&time2, NULL);	if(index == 0){		diff = (1000000.0 * (time2.tv_sec-time0.tv_sec)+ time2.tv_usec-time0.tv_usec)/1000000.0;	}else{		diff = (1000000.0 * (time2.tv_sec-time1.tv_sec)+ time2.tv_usec-time1.tv_usec)/1000000.0;	}	t0 = round(diff);	t1 = t0%(dv_core->rec_time_ms[index]/1000);		return t1;}int collide_save_file(int index){	int cur_time = 0;	CHECK_NULL_POINTER(dv_core);	cur_time = recorder_get_cur_rectime(index);	if(cur_time < 0){		return -1;	}	if(index == 0){		pthread_mutex_lock(&dv_core->mutex0[index]);		if(cur_collide_f0 == 1){			if(cur_time > dv_core->rec_time_ms[0]/1000 - 10) 				collide_f02 = 1;		}else{			if(cur_time < 10){				if((first_file_f0 == 1) || (pre_collide_f0 == 1)){										collide_f00 = 0;				}else{					collide_f00 = 1;				}				collide_f01 = 1;				collide_f02 = 0;			}else if(cur_time > dv_core->rec_time_ms[0]/1000 - 10){ 				collide_f00 = 0;				collide_f01 = 1;				collide_f02 = 1;			}else{				collide_f00 = 0;				collide_f01 = 1;				collide_f02 = 0;				}		}		pthread_mutex_unlock(&dv_core->mutex0[index]);	}else{		pthread_mutex_lock(&dv_core->mutex0[index]);		if(cur_collide_f1 == 1){			if(cur_time > dv_core->rec_time_ms[1]/1000 - 10) 				collide_f12 = 1;		}else{			if(cur_time < 10){				if((first_file_f1 == 1) || (pre_collide_f1 == 1)){										collide_f10 = 0;				}else{					collide_f10 = 1;				}				collide_f11 = 1;				collide_f12 = 0;			}else if(cur_time > dv_core->rec_time_ms[1]/1000 - 10){ 				collide_f10 = 0;				collide_f11 = 1;				collide_f12 = 1;			}else{				collide_f10 = 0;				collide_f11 = 1;				collide_f12 = 0;			}		}		pthread_mutex_unlock(&dv_core->mutex0[index]);	}	return 0;}int recorder_part_info_set(rec_media_part_info_t *info){	if(!dv_core)	{		printf("malloc failed!\n");		return -1;	}	dv_core->cycle_rec_time[0] = info->cycle_rec_time[0];	dv_core->cycle_rec_time[1] = info->cycle_rec_time[1];	dv_core->mute_en[0] = info->mute_en[0];	dv_core->mute_en[1] = info->mute_en[1];	dv_core->time_water_en[0] = info->time_water_en[0];	dv_core->time_water_en[1] = info->time_water_en[1];	__dv_get_cycle_rec_time(dv_core, 0);	__dv_get_cycle_rec_time(dv_core, 1);	TRsetMaxRecordTimeMs(dv_core->mTrecorder[0], dv_core->rec_time_ms[0]);	TRsetMaxRecordTimeMs(dv_core->mTrecorder[1], dv_core->rec_time_ms[1]);	TRsetAudioMute(dv_core->mTrecorder[0], dv_core->mute_en[0]);	TRsetAudioMute(dv_core->mTrecorder[1], dv_core->mute_en[1]);	TRsetCameraEnableWM(dv_core->mTrecorder[0], WM_POS_X_F, WM_POS_Y_F, dv_core->time_water_en[0]);	TRsetCameraEnableWM(dv_core->mTrecorder[1], WM_POS_X_B, WM_POS_Y_B, dv_core->time_water_en[1]);	return 0;}int recorder_init_info(rec_media_info_t *info){	int i;	dv_core = malloc(sizeof(__dv_core_t));	if(!dv_core){		printf("malloc failed!\n");		return -1;	}	memset(dv_core, 0, sizeof(__dv_core_t));	dv_core->pip_rect.x = info->pip_rect.x;	dv_core->pip_rect.y = info->pip_rect.y;	dv_core->pip_rect.width = info->pip_rect.width;	dv_core->pip_rect.height = info->pip_rect.height;	dv_core->show_rect.x = info->show_rect.x;	dv_core->show_rect.y = info->show_rect.y;	dv_core->show_rect.width = info->show_rect.width;	dv_core->show_rect.height = info->show_rect.height;	dv_core->cam_quality_mode[0] = info->cam_quality_mode[0];	dv_core->cam_quality_mode[1] = info->cam_quality_mode[1];	dv_core->rec_quality_mode[0] = info->rec_quality_mode[0];	dv_core->rec_quality_mode[1] = info->rec_quality_mode[1];	dv_core->source_size[0].width = info->source_size[0].width;	dv_core->source_size[0].height = info->source_size[0].height;	dv_core->source_size[1].width = info->source_size[1].width;	dv_core->source_size[1].height = info->source_size[1].height;	dv_core->cycle_rec_time[0] = info->cycle_rec_time[0];	dv_core->cycle_rec_time[1] = info->cycle_rec_time[1];	dv_core->mute_en[0] = info->mute_en[0];	dv_core->mute_en[1] = info->mute_en[1];	dv_core->time_water_en[0] = info->time_water_en[0];	dv_core->time_water_en[1] = info->time_water_en[1];	dv_core->pre_mode[0] = info->pre_mode[0];	dv_core->pre_mode[1] = info->pre_mode[1];	dv_core->source_frate[0] = info->source_frate[0];	dv_core->source_frate[1] = info->source_frate[1];	dv_core->record_sta[0] = RECORD_UNINIT;	dv_core->record_sta[1] = RECORD_UNINIT;	for(i = 0; i < SENSOR_NUM; i++){		pthread_mutex_init (&dv_core->mutex0[i], NULL);		pthread_mutex_init (&dv_core->mutex1[i], NULL);	}	return 0;}int recorder_exit_info(void){	int i;	CHECK_NULL_POINTER(dv_core);	for(i = 0; i < SENSOR_NUM; i++){		pthread_mutex_destroy(&dv_core->mutex0[i]);		pthread_mutex_destroy(&dv_core->mutex1[i]);	}	free(dv_core);	dv_core = NULL;	return 0;}int create_rec_list(void){	rec_list_A = create_list_by_path(PARTH_A);	rec_list_B = create_list_by_path(PARTH_B);	if(!rec_list_A || !rec_list_B)		return -1;	return 0;}int destroy_rec_list(void){	if(rec_list_A){		destroy_list(rec_list_A);		rec_list_A = NULL;	}	if(rec_list_B){		destroy_list(rec_list_B);		rec_list_B = NULL;	}	return 0;}