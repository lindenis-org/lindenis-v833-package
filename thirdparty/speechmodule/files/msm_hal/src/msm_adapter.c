/**
 * @file msm_adapter.c
 * @brief
 * @author Humble
 * @version 1.0.0
 * @par Copyright  (c)
 *		Midea
 */
#include "msm_adapter.h"
#include "ms_common.h"

///TODO
#if defined(CHIP_PLATFORM_REALTEK_8710BN)
#include "ms_hal_wlan.h"
#include "ms_chip.h"
#include "ms_hal_sniffer.h"
#endif


#if defined(OSTYPE_LINUX)
/*Posix standard headers*/
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/param.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/select.h>
#include <fcntl.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <unistd.h>
#include <pthread.h>
/*C standard headers*/
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

#include <ctype.h>
#include <stdbool.h>
#include <endian.h>
#include <stdint.h>
#include <fcntl.h>
#include <stdarg.h>

/* Functions */
#include <assert.h>
#define MS_ASSERT assert

#elif defined(OSTYPE_FREERTOS)
/*FreeRTOS headers */
#include "FreeRTOS.h"
#include "lwip/sockets.h"
#include "lwip/netdb.h"
#include "semphr.h"
#include "task.h"
/*C standard headers*/
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

#include <stdint.h>
#else
///TODO
#endif


#if defined(OSTYPE_LINUX)
typedef pthread_mutex_t			msm_mux_lock_type;
#elif defined(OSTYPE_FREERTOS)
typedef SemaphoreHandle_t		msm_mux_lock_type;
#else
///TODO
#endif

#if defined(OSTYPE_LINUX) || defined(OSTYPE_FREERTOS)
typedef fd_set				msm_fd_set_t;
#else
///TODO
#endif

pthread_mutex_t wake_mux_Lock;
msm_mux_lock_type msm_sst_mux_lock;
msm_fd_set_t		   fd_set_val;

/* Contents of file 2C3AE80810DA.bin , just for test */
const long int _C3AE80810DA_bin_size = 2048;
const unsigned char _C3AE80810DA_bin[2048] = {
    0x20, 0x2C, 0x3A, 0xE8, 0x08, 0x10, 0xDA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x5F, 0x93, 0xDC, 0x7F, 0x18, 0xDD, 0xC4, 0x2C, 0x76, 0x1F, 0x2E, 0xAD, 0xA4, 0x82, 0x23, 0xF1,
    0xD9, 0x66, 0x86, 0x1A, 0x2A, 0xC3, 0x9B, 0x28, 0xF7, 0xC2, 0x67, 0xBB, 0x28, 0x27, 0x75, 0x55,
    0x6A, 0x57, 0x31, 0x21, 0x96, 0xFC, 0x89, 0x1E, 0x77, 0xBC, 0x34, 0x23, 0xE9, 0x68, 0x5D, 0xD3,
    0xCB, 0xE6, 0xDE, 0x56, 0x37, 0xB4, 0xD4, 0xBA, 0x26, 0x99, 0x4A, 0xE0, 0xC9, 0x4B, 0x10, 0x3E,
    0x3C, 0xE7, 0x25, 0xC0, 0x98, 0x25, 0xE2, 0xBC, 0xF2, 0xD0, 0xFB, 0xF5, 0xA4, 0xA7, 0x22, 0x50,
    0xEA, 0x50, 0x8E, 0xA8, 0xCA, 0x34, 0x50, 0xBB, 0x82, 0xEA, 0x79, 0x72, 0xC3, 0xB6, 0x21, 0x13,
    0x47, 0x14, 0xE7, 0x48, 0x52, 0x99, 0xC0, 0x95, 0xD0, 0x5A, 0xB1, 0x3B, 0xC8, 0xA9, 0xA8, 0xBC,
    0x95, 0x2A, 0xFB, 0xD0, 0xF0, 0x03, 0xF7, 0x2C, 0x29, 0xC5, 0xB6, 0xB3, 0xEC, 0x95, 0xEC, 0x12,
    0xD3, 0xEA, 0x67, 0xCD, 0xDF, 0x0C, 0xA5, 0x32, 0x4A, 0xC7, 0xC1, 0x5A, 0x69, 0xD0, 0xD7, 0x2B,
    0x0F, 0x79, 0x51, 0xFD, 0xB0, 0x5D, 0x6D, 0x6C, 0x51, 0x96, 0xAD, 0x1F, 0xD2, 0x70, 0x74, 0xD0,
    0x8E, 0x13, 0xA5, 0x08, 0x8B, 0x8B, 0x2C, 0x8C, 0x65, 0xA5, 0xEB, 0x21, 0xAE, 0x37, 0x9E, 0x31,
    0x3F, 0x78, 0xE1, 0x56, 0xAC, 0xB8, 0x9E, 0x42, 0x16, 0xAA, 0xAB, 0x3C, 0x23, 0x74, 0xCC, 0xF9,
    0xBD, 0x64, 0x82, 0x9F, 0xB5, 0x5C, 0x83, 0xE9, 0x88, 0x83, 0xFC, 0x38, 0x5B, 0x34, 0xAE, 0xBD,
    0x2C, 0x39, 0xBE, 0x5A, 0xE5, 0x2A, 0x7E, 0xA4, 0x1F, 0x1D, 0xA9, 0x28, 0x85, 0x9C, 0xE1, 0x0B,
    0xA2, 0x8C, 0x6F, 0x42, 0x07, 0x37, 0x92, 0xCD, 0x08, 0x3D, 0x06, 0x0D, 0xF5, 0x01, 0x67, 0x7D,
    0x81, 0x8E, 0xD5, 0x5A, 0xF9, 0xCC, 0xCB, 0xFE, 0x7F, 0x0B, 0x8D, 0xD5, 0x8C, 0x72, 0x0F, 0x52,
    0xA0, 0x8B, 0x53, 0x04, 0x9E, 0x9C, 0x0B, 0x88, 0xCD, 0x85, 0xBB, 0x4B, 0xC8, 0xD3, 0x89, 0xC6,
    0x35, 0xF3, 0xA7, 0x81, 0x5D, 0x38, 0xCF, 0x8A, 0x4D, 0xAA, 0x3E, 0x75, 0xD2, 0x7A, 0x45, 0xCD,
    0x7F, 0x67, 0x77, 0x28, 0xE8, 0x6E, 0x8F, 0xA0, 0x23, 0x92, 0xA9, 0x24, 0x5C, 0xBE, 0x0C, 0x72,
    0x3D, 0x6C, 0x40, 0x04, 0x83, 0x24, 0x4A, 0x2A, 0xA3, 0xC7, 0x8F, 0xD2, 0x76, 0x92, 0x83, 0x3B,
    0xF6, 0xB4, 0xFC, 0xE9, 0xCF, 0x46, 0x9D, 0xAF, 0x22, 0xA4, 0xAF, 0xEF, 0xAC, 0x0F, 0x1E, 0x04,
    0xAC, 0x8A, 0x7A, 0x35, 0x93, 0x1D, 0xC5, 0xA2, 0x53, 0xA3, 0xBC, 0x35, 0x67, 0x7F, 0x56, 0x1C,
    0xA1, 0x28, 0xA2, 0x8B, 0x5A, 0x3C, 0x2F, 0x76, 0xD6, 0xB2, 0x83, 0xA8, 0x4A, 0x14, 0xF6, 0x0A,
    0xB1, 0xB9, 0x05, 0xCB, 0xDB, 0x9C, 0xDA, 0x45, 0xB5, 0x85, 0xEC, 0xDE, 0x57, 0x98, 0x34, 0xD8,
    0x54, 0x02, 0xEE, 0xA2, 0x79, 0xCB, 0xB7, 0x5F, 0x4A, 0x75, 0x85, 0xAF, 0x31, 0x1E, 0xE8, 0x56,
    0xA4, 0x1E, 0x4A, 0x11, 0x74, 0xC0, 0xA9, 0x83, 0x5C, 0x24, 0xB8, 0xAD, 0x55, 0xEE, 0x94, 0xE1,
    0xF5, 0x1F, 0x25, 0xE0, 0x3A, 0xB3, 0xAE, 0x4D, 0xEC, 0x41, 0x53, 0x90, 0x9F, 0x30, 0xD4, 0xA2,
    0x63, 0x96, 0x12, 0x75, 0xF8, 0x2C, 0x75, 0x99, 0x12, 0x84, 0x50, 0xC3, 0x93, 0x70, 0x68, 0xBC,
    0xF2, 0xD8, 0xA6, 0x21, 0x7D, 0xC7, 0xED, 0x51, 0x5A, 0xFB, 0x8F, 0xA5, 0xD1, 0x9A, 0x4C, 0x7E,
    0x97, 0xD7, 0xD4, 0x3A, 0x54, 0xD1, 0x28, 0xCB, 0xFE, 0x49, 0xAA, 0x5A, 0x06, 0xB1, 0x89, 0xD5,
    0x9B, 0xB3, 0xAE, 0xC8, 0x95, 0x25, 0xC4, 0xC3, 0xE0, 0x92, 0x44, 0xCD, 0x6E, 0x8D, 0x8F, 0x94,
    0xA0, 0x55, 0xE0, 0x0C, 0x16, 0xB6, 0xA3, 0xAF, 0xEF, 0x08, 0x86, 0x0E, 0xCD, 0x9F, 0x83, 0xFC,
    0x6D, 0x95, 0x49, 0xDB, 0xE5, 0x4D, 0x8C, 0x07, 0x03, 0xC5, 0x05, 0x27, 0x41, 0xC4, 0xC8, 0x79,
    0x1C, 0xD0, 0xB3, 0xCC, 0xB7, 0xC0, 0x1F, 0x01, 0x14, 0xF3, 0x40, 0xDC, 0x57, 0x78, 0xB6, 0x65,
    0x95, 0x15, 0xE8, 0x11, 0x7A, 0x37, 0x20, 0x33, 0x6D, 0xB4, 0xC8, 0xAD, 0x93, 0x88, 0x93, 0x71,
    0x07, 0x92, 0x5B, 0xE1, 0x1D, 0x69, 0xC0, 0x05, 0x2E, 0xE6, 0x14, 0xB9, 0x89, 0x45, 0x0E, 0x8E,
    0x59, 0x10, 0x84, 0x83, 0xE1, 0xAF, 0xFE, 0xA3, 0x00, 0x4D, 0x05, 0xE1, 0x3F, 0x27, 0xDB, 0xE3,
    0x7D, 0x31, 0xB2, 0xDC, 0x6F, 0x5D, 0x05, 0xA4, 0x17, 0xE8, 0x02, 0xD2, 0x26, 0xF2, 0xA2, 0x00,
    0x02, 0x1D, 0x90, 0x6E, 0xFB, 0xE4, 0x92, 0xE3, 0x50, 0x7C, 0x22, 0xEF, 0x3C, 0x12, 0x42, 0x76,
    0x25, 0xE6, 0x96, 0x84, 0x71, 0x04, 0xEE, 0xAD, 0x6D, 0xBB, 0xC4, 0x25, 0x6A, 0xBC, 0xA0, 0x3C,
    0x8A, 0x03, 0x30, 0xD2, 0x3F, 0x9D, 0x41, 0x27, 0x98, 0xF1, 0xAC, 0x7D, 0xAE, 0xA0, 0xDD, 0x48,
    0x48, 0xC7, 0x7E, 0xE9, 0x73, 0x91, 0xCF, 0xD9, 0xC0, 0xDC, 0x62, 0x62, 0xDA, 0xE0, 0xCF, 0x09,
    0x80, 0x6C, 0xE1, 0x7A, 0x17, 0xD8, 0xFB, 0x90, 0xAE, 0xA8, 0xFA, 0x1B, 0xFB, 0x9D, 0xE3, 0x2E,
    0xD0, 0x5C, 0x1C, 0x3F, 0xB8, 0x17, 0xE6, 0x57, 0xF3, 0x20, 0x46, 0x67, 0x48, 0x64, 0x3E, 0x3A,
    0x7B, 0x57, 0x48, 0x98, 0x2F, 0x08, 0x0E, 0xF8, 0x3B, 0x9E, 0x61, 0x06, 0x3F, 0x4A, 0x7A, 0xA6,
    0x5B, 0xC1, 0x6C, 0xA3, 0xA0, 0x71, 0x3F, 0xF4, 0xC5, 0x22, 0xF8, 0xC5, 0xCF, 0x50, 0x44, 0xB5,
    0x07, 0x4F, 0xFA, 0x9D, 0x09, 0x01, 0x83, 0x7B, 0x83, 0xFE, 0xFE, 0x6C, 0x4E, 0x10, 0x1E, 0xB4,
    0xB8, 0xBE, 0xD4, 0x1B, 0x07, 0x8F, 0x04, 0x40, 0x71, 0xFC, 0xE5, 0x17, 0x98, 0xB4, 0x19, 0x05,
    0xAA, 0x5A, 0x8C, 0x7A, 0xD8, 0x31, 0x10, 0xF5, 0x73, 0x03, 0xB9, 0xCE, 0x96, 0x85, 0xFB, 0x50,
    0x7F, 0x89, 0x12, 0xA1, 0x25, 0x76, 0x96, 0x81, 0x38, 0xB3, 0xC2, 0x19, 0x1A, 0x9E, 0x23, 0xBE,
    0x7F, 0x7E, 0xB7, 0x4E, 0x40, 0xEF, 0xAE, 0xDD, 0x84, 0x89, 0x1C, 0x99, 0x90, 0xF4, 0x4D, 0x10,
    0x03, 0xB9, 0xAD, 0x75, 0x46, 0x2D, 0xB7, 0xE1, 0x38, 0x80, 0x97, 0xD3, 0x6B, 0xC7, 0x46, 0x0B,
    0xAF, 0x70, 0xFA, 0xA7, 0x48, 0xA6, 0x8B, 0xFB, 0xB6, 0xDB, 0x40, 0x62, 0x50, 0x45, 0x48, 0xF9,
    0x97, 0x03, 0xA7, 0xBD, 0x02, 0x20, 0x58, 0x2A, 0x54, 0x91, 0x3A, 0x95, 0x56, 0xDF, 0x9E, 0x75,
    0xB5, 0xB4, 0x9F, 0xC2, 0xA6, 0x86, 0x8A, 0x05, 0xFC, 0x0F, 0xD9, 0xE9, 0xA6, 0xAF, 0xE1, 0x1E,
    0x2F, 0xA6, 0xBE, 0x61, 0xB6, 0x3E, 0xCA, 0x9B, 0x82, 0x4F, 0x5F, 0xEF, 0xAE, 0xD6, 0x5E, 0xE6,
    0xE7, 0x17, 0xDF, 0x77, 0xF0, 0xAA, 0x7E, 0xA1, 0x69, 0xBC, 0x59, 0x2D, 0xFE, 0x9B, 0x25, 0x9F,
    0x63, 0x1B, 0xDF, 0x50, 0x09, 0x13, 0x67, 0x5E, 0xC3, 0xB6, 0xC9, 0xEC, 0x59, 0x07, 0x13, 0xE5,
    0x5F, 0xFD, 0xFC, 0x07, 0x55, 0xD5, 0x9B, 0xF0, 0x61, 0xE2, 0x4D, 0xA8, 0x9E, 0xA5, 0x70, 0x43,
    0xBF, 0x7C, 0x33, 0x6A, 0x0C, 0x61, 0x94, 0xBF, 0x98, 0x58, 0xD7, 0x38, 0x4E, 0x68, 0xB9, 0x0E,
    0x3F, 0xE6, 0x97, 0x7E, 0x87, 0x3F, 0xA2, 0x74, 0xFE, 0x08, 0x70, 0x79, 0xD3, 0x30, 0x03, 0x53,
    0x7B, 0x57, 0x48, 0x98, 0x2F, 0x08, 0x0E, 0xF8, 0x3B, 0x9E, 0x61, 0x06, 0x3F, 0x4A, 0x7A, 0xA6,
    0x75, 0xD0, 0xDB, 0x5D, 0xFC, 0xC4, 0xFE, 0x81, 0x1E, 0xD5, 0x78, 0x3B, 0x72, 0x24, 0x41, 0x36,
    0x42, 0x14, 0x64, 0x28, 0x09, 0x6D, 0xA2, 0x80, 0xCE, 0xA8, 0x5F, 0x53, 0x78, 0x27, 0x9C, 0x3F,
    0x57, 0x94, 0xDC, 0xCF, 0xA3, 0x57, 0x91, 0x27, 0xBF, 0x0B, 0xD0, 0x98, 0xB1, 0x27, 0x09, 0x98,
    0x89, 0xF0, 0x17, 0x0E, 0x39, 0x92, 0x0C, 0x1B, 0x19, 0xC9, 0x04, 0x2B, 0xB2, 0x8E, 0xCD, 0x2C,
    0x65, 0x6F, 0xF5, 0x8F, 0xA4, 0xC4, 0x8A, 0x7D, 0xC4, 0x63, 0xF0, 0x4E, 0x4A, 0xFE, 0x97, 0x70,
    0x96, 0xE6, 0xB7, 0xBF, 0x28, 0x2B, 0x55, 0x45, 0xD5, 0x40, 0x90, 0xA7, 0xE3, 0xC1, 0xBF, 0x49,
    0xB1, 0x54, 0xDD, 0x73, 0x3C, 0x26, 0x17, 0xA3, 0x3A, 0xB7, 0xCE, 0x39, 0x44, 0x6C, 0x39, 0x8E,
    0x0A, 0x6F, 0x90, 0xEA, 0x70, 0x52, 0x6A, 0x29, 0x9B, 0x8F, 0xEB, 0xFF, 0xCE, 0xB3, 0xA7, 0x91,
    0xFE, 0xA7, 0x90, 0xCA, 0xA6, 0x10, 0xE8, 0x78, 0xDF, 0xE6, 0x54, 0x0F, 0x69, 0x09, 0xB9, 0xC0,
    0x7D, 0xDB, 0x22, 0x07, 0x2B, 0xA2, 0x9F, 0x88, 0x46, 0x20, 0x49, 0xF4, 0xEB, 0x63, 0x37, 0x76,
    0x4C, 0xCA, 0x84, 0xAD, 0xE9, 0xF9, 0xC0, 0x7F, 0xE0, 0x97, 0xC2, 0x7E, 0x15, 0xB5, 0xD3, 0x5B,
    0xA0, 0x3F, 0x9E, 0xC1, 0x82, 0x9C, 0x73, 0xED, 0x33, 0xC2, 0x29, 0x79, 0x15, 0xEC, 0x04, 0x7B,
    0xE6, 0xE6, 0x17, 0xA5, 0xB2, 0x51, 0xBF, 0x0B, 0x79, 0x20, 0x6F, 0xE7, 0xBD, 0xF6, 0x94, 0xAA,
    0xE4, 0x08, 0xDC, 0x70, 0x5D, 0xB7, 0x91, 0x80, 0x81, 0xEE, 0x71, 0xEB, 0xC5, 0x27, 0x6B, 0x22,
    0xB6, 0xF8, 0x17, 0xAC, 0x47, 0xDC, 0x8D, 0x44, 0xEC, 0x36, 0x3A, 0x84, 0x9C, 0xA5, 0x7B, 0xA7,
    0x36, 0xAA, 0x18, 0xA5, 0x11, 0x0F, 0xE6, 0xBC, 0x60, 0x49, 0x01, 0x65, 0xB1, 0x7A, 0x7C, 0xDA,
    0x7B, 0x57, 0x48, 0x98, 0x2F, 0x08, 0x0E, 0xF8, 0x3B, 0x9E, 0x61, 0x06, 0x3F, 0x4A, 0x7A, 0xA6,
    0x32, 0x29, 0x8B, 0x6D, 0x8E, 0x21, 0xB3, 0x68, 0xDB, 0xD9, 0xFE, 0x04, 0xDA, 0xDE, 0x18, 0xBE,
    0x74, 0xCF, 0x0B, 0xF1, 0x81, 0x51, 0x0C, 0xE7, 0xA3, 0xAE, 0x5C, 0x05, 0x9A, 0x7F, 0xA2, 0xF9,
    0x90, 0xDF, 0x6D, 0xD9, 0x49, 0x32, 0xD5, 0xC2, 0x69, 0xEF, 0xD9, 0x63, 0x37, 0x77, 0x6A, 0xF6,
    0x08, 0x8D, 0xAC, 0x20, 0xD5, 0xF4, 0xF3, 0xE5, 0x7A, 0x52, 0x18, 0x03, 0xF3, 0xF0, 0xB9, 0xEC,
    0x74, 0x0B, 0x79, 0xEA, 0xF7, 0x95, 0xA3, 0xA4, 0x4F, 0x54, 0xF9, 0x52, 0x8D, 0xF8, 0x0B, 0x7B,
    0x10, 0xC8, 0x08, 0x30, 0xC2, 0x48, 0xC0, 0xDA, 0x0A, 0x03, 0x90, 0xC8, 0xA4, 0x13, 0xA3, 0xC3,
    0x8B, 0xB7, 0xCF, 0x49, 0x9B, 0x93, 0xB2, 0xE3, 0x78, 0x7A, 0xAE, 0xB7, 0x02, 0x76, 0xEB, 0x6B,
    0x87, 0x25, 0x5B, 0x8C, 0xA7, 0x30, 0xF6, 0x4E, 0xAB, 0xD9, 0xD9, 0x08, 0x42, 0x2C, 0x10, 0x76,
    0x2A, 0xD2, 0x2E, 0x0B, 0x86, 0x9B, 0xDA, 0x06, 0x19, 0x8E, 0x50, 0xF5, 0xB2, 0x1A, 0x7D, 0x8F,
    0x00, 0x2A, 0x38, 0x53, 0x7B, 0x03, 0xD4, 0x5F, 0xCA, 0xDD, 0x5D, 0xC6, 0x1A, 0xC5, 0xBD, 0x01,
    0xFD, 0x29, 0xA9, 0x24, 0xC6, 0x7B, 0x38, 0xC3, 0x2D, 0xDA, 0x61, 0xEB, 0x15, 0xCD, 0x55, 0x42,
    0xC6, 0xE4, 0x47, 0x90, 0xCD, 0x77, 0xA1, 0xAC, 0xF4, 0x99, 0x85, 0x54, 0x26, 0xA0, 0x86, 0xF4,
    0x64, 0x76, 0x7F, 0x0E, 0x36, 0x6F, 0xD4, 0xC9, 0x52, 0xA0, 0xC5, 0x53, 0x2A, 0x3E, 0x24, 0x81,
    0xFF, 0x90, 0x97, 0xC1, 0x67, 0x4B, 0x49, 0xF3, 0xBE, 0xE0, 0xB2, 0x90, 0xE3, 0x21, 0xAE, 0x8E,
    0xFF, 0x62, 0x3D, 0x08, 0xE8, 0x41, 0x3F, 0xF0, 0x86, 0x6B, 0x67, 0x85, 0xDF, 0xCD, 0x77, 0x08,
    0x86, 0xDB, 0xB2, 0x20, 0x64, 0x88, 0x12, 0xD5, 0x33, 0x07, 0x88, 0x30, 0x1F, 0x8A, 0xF3, 0xF0,
    0x7B, 0x57, 0x48, 0x98, 0x2F, 0x08, 0x0E, 0xF8, 0x3B, 0x9E, 0x61, 0x06, 0x3F, 0x4A, 0x7A, 0xA6,
    0x72, 0x0A, 0x13, 0xEC, 0xEF, 0x43, 0xB7, 0x46, 0xBD, 0xE5, 0x1C, 0x48, 0xF7, 0x60, 0x50, 0x3D,
    0x7A, 0x93, 0x99, 0xEF, 0x5D, 0xD8, 0xF5, 0xFA, 0x7F, 0x09, 0x32, 0x1B, 0xBA, 0xA0, 0x94, 0x5B,
    0x23, 0x3C, 0x64, 0x69, 0xB5, 0x20, 0xF3, 0x57, 0xA6, 0xC9, 0xDD, 0xA6, 0xBC, 0xCE, 0x46, 0xCC,
    0x95, 0x81, 0x78, 0xFC, 0xD1, 0x73, 0xDB, 0x95, 0x1D, 0x15, 0x55, 0x9F, 0x11, 0x47, 0xBB, 0x40,
    0x89, 0x7A, 0x06, 0xC2, 0xB2, 0x7D, 0x7E, 0xEC, 0x04, 0xAA, 0xF1, 0x91, 0xA3, 0x8B, 0x29, 0x7A,
    0xF5, 0xCE, 0xE7, 0x0B, 0xCB, 0x0C, 0xBF, 0x6A, 0xE6, 0x13, 0x9B, 0xF3, 0x1F, 0x61, 0x9F, 0xBB,
    0x67, 0xB7, 0x38, 0x17, 0x61, 0xC6, 0xB4, 0x5E, 0xD8, 0xCA, 0x07, 0xB4, 0x3D, 0xB8, 0xA7, 0x2D,
    0x7F, 0x1F, 0x8E, 0x94, 0xEC, 0xA1, 0x91, 0x62, 0x49, 0xB4, 0xD0, 0x33, 0x8B, 0xC1, 0xBB, 0x17,
    0x62, 0x7F, 0xBC, 0x2D, 0xAA, 0xD8, 0x14, 0x53, 0x29, 0x49, 0x27, 0x21, 0xB8, 0x69, 0x84, 0x75,
    0x41, 0x52, 0x78, 0xBA, 0x57, 0x96, 0x96, 0x41, 0x9F, 0x37, 0x8C, 0xB3, 0x87, 0xA8, 0x11, 0xD2,
    0xB8, 0xE6, 0x78, 0xA7, 0xE5, 0x15, 0x4D, 0xD5, 0x69, 0x2D, 0x61, 0x63, 0x2A, 0xBB, 0x7A, 0x51,
    0xB5, 0xF0, 0x3B, 0xCB, 0x17, 0xB9, 0xA9, 0x71, 0xC3, 0x9E, 0x1C, 0x2C, 0x92, 0x26, 0x6F, 0x84,
    0x33, 0x90, 0x1D, 0x31, 0x26, 0x1F, 0x04, 0xFB, 0x8C, 0x6C, 0x3E, 0xAF, 0x59, 0xBC, 0xAB, 0x40,
    0x22, 0x07, 0x9A, 0xA2, 0xA6, 0x51, 0xC9, 0x51, 0x99, 0x37, 0x1A, 0x34, 0x65, 0xA5, 0xE9, 0x8F,
    0x05, 0x2B, 0x95, 0x9D, 0x66, 0x9B, 0x89, 0xC1, 0x14, 0xA3, 0xBD, 0xD6, 0x9E, 0x97, 0x35, 0x98,
    0xFF, 0x90, 0x7C, 0x49, 0x5A, 0xBF, 0xFD, 0x32, 0x6B, 0xB6, 0x6A, 0x65, 0x03, 0xF6, 0x97, 0x24,
    0x5F, 0x93, 0xDC, 0x7F, 0x18, 0xDD, 0xC4, 0x2C, 0x76, 0x1F, 0x2E, 0xAD, 0xA4, 0x82, 0x23, 0xF1,
    0xD9, 0x66, 0x86, 0x1A, 0x2A, 0xC3, 0x9B, 0x28, 0xF7, 0xC2, 0x67, 0xBB, 0x28, 0x27, 0x75, 0x55,
    0xC8, 0x0F, 0xC7, 0x88, 0x42, 0x3B, 0x3E, 0x66, 0x74, 0x42, 0xE5, 0x6A, 0x6A, 0xEA, 0x5D, 0x4C,
    0xD0, 0x70, 0x7E, 0x03, 0x10, 0x3D, 0xF2, 0xAF, 0x33, 0x9F, 0x2A, 0xD6, 0x7F, 0x4A, 0xAE, 0xBF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xBB, 0xE7, 0x70, 0x04, 0x81, 0xCE, 0x78, 0xFC, 0x04, 0x0B, 0xB1, 0xDD, 0xE4, 0xD8, 0xFE, 0x55,
    0x98, 0x52, 0x27, 0xC9, 0xA4, 0x24, 0x01, 0xFA, 0x7D, 0x33, 0xDD, 0x09, 0xE5, 0xCD, 0x83, 0xA4
};
int msm_printf(const char* format, ...)
{
	     va_list ap;
         int ret = -1;

         va_start(ap, format);

#if defined(OSTYPE_LINUX)
	ret = vprintf(format, ap);
#elif defined(CHIP_PLATFORM_REALTEK_8710BN)
         ret = rtl_vprintf(format, ap);
#else
	///TODO...
#endif
         va_end(ap);

         return ret;
}

msm_result_t msm_flash_read_license_operation_info(uint8_t *buf, unsigned int len)
{
#if defined(MSM_DEBUG_LICENSE)
	//Note: One MAC , one License
	memcpy(buf, _C3AE80810DA_bin, _C3AE80810DA_bin_size);

	return MSM_RESULT_SUCCESS;
#else
	FILE* fp = fopen(MSMART_OP_LICENSE_FILE, "rb");
	//Note: One MAC , one License
	msm_printf("%s %d %p,%d\r\n", __FUNCTION__, __LINE__, fp, len);
	if (fp != NULL) {
	     fread(buf, 1, len, fp);
	     fclose(fp);
	     return MSM_RESULT_SUCCESS;
	}else{
	     return MSM_RESULT_ERROR;
	}
#endif
}

msm_result_t msm_flash_save_license_operation_info(uint8_t *buf, unsigned int len)
{
#if defined(MSM_DEBUG_LICENSE)
	//Note: One MAC , one License
	msm_printf("%s %d debug\r\n", __FUNCTION__, __LINE__);
	return MSM_RESULT_SUCCESS;
#else
	//Note: One MAC , one License
	FILE* fp = fopen(MSMART_OP_LICENSE_FILE, "w+");
	//Note: One MAC , one License
	if (fp != NULL) {
	     fwrite(buf, 1, len, fp);
	     fclose(fp);
	     return MSM_RESULT_SUCCESS;
	}else{
	     return MSM_RESULT_ERROR;
	}
#endif
}

msm_result_t msm_flash_read_license_factory_info(uint8_t *buf, unsigned int len)
{
#if defined(MSM_DEBUG_LICENSE)
	//Note: One MAC , one License
	msm_printf("%s %d debug\r\n", __FUNCTION__, __LINE__);
	memcpy(buf, _C3AE80810DA_bin, _C3AE80810DA_bin_size);
	return MSM_RESULT_SUCCESS;
#else
	FILE* fp = fopen(MSMART_MACBIN_FILE, "rb");
	//Note: One MAC , one License
	msm_printf("%s %d %p,%d\r\n", __FUNCTION__, __LINE__, fp, len);
	if (fp != NULL) {
	     fread(buf, 1, len, fp);
	     fclose(fp);
	     return MSM_RESULT_SUCCESS;
	}else{
	     return MSM_RESULT_ERROR;
	}
#endif
}

void msm_timer_delay_ms(int ms)
{
#if defined(OSTYPE_LINUX)
	usleep(ms*1000);
#elif defined(OSTYPE_FREERTOS)
	vTaskDelay(ms/portTICK_RATE_MS);
#else
	///TODO
#endif
}

unsigned int msm_timer_get_systime_ms(void)
{
#if defined(OSTYPE_LINUX)
       struct timeval current_tm;

	gettimeofday(&current_tm, NULL);
	return (current_tm.tv_sec<<10) + (current_tm.tv_usec>>10);

#elif defined(OSTYPE_FREERTOS)
	unsigned int timeout_ms = xTaskGetTickCount()/portTICK_PERIOD_MS;
	return timeout_ms;
#else
	///TODO
#endif
}

unsigned int msm_timer_tickcount_get(void)
{
#if defined(OSTYPE_LINUX)
	return times( NULL );
#elif defined(OSTYPE_FREERTOS)
	unsigned int  msRet;
	msRet =  ( uint32_t )xTaskGetTickCount();
	return msRet;
#else
	///TODO
	return 0;
#endif
}

msm_result_t msm_sst_mutex_init(void)//msm_sst_mutex_init , del mutex_id
{
#if defined(OSTYPE_LINUX)
	pthread_mutex_init(&msm_sst_mux_lock, NULL);
#elif defined(OSTYPE_FREERTOS)
	msm_sst_mux_lock = xSemaphoreCreateMutex();
#else
	///TODO
#endif

	return MSM_RESULT_SUCCESS;
}
msm_result_t msm_sst_mutex_lock(void)
{
#if defined(OSTYPE_LINUX)
	pthread_mutex_lock(&msm_sst_mux_lock);
#elif defined(OSTYPE_FREERTOS)
	xSemaphoreTake(msm_sst_mux_lock, portMAX_DELAY );
#else
	///TODO
#endif

	return MSM_RESULT_SUCCESS;
}
msm_result_t msm_sst_mutex_unlock(void)
{
#if defined(OSTYPE_LINUX)
	pthread_mutex_unlock(&msm_sst_mux_lock);
#elif defined(OSTYPE_FREERTOS)
	xSemaphoreGive(msm_sst_mux_lock);
#else
	///TODO
#endif

	return MSM_RESULT_SUCCESS;
}
msm_result_t msm_sst_mutex_delete(void)
{
#if defined(OSTYPE_LINUX)
	pthread_mutex_destroy(&msm_sst_mux_lock);
#elif defined(OSTYPE_FREERTOS)
	vSemaphoreDelete(msm_sst_mux_lock);
#else
	///TODO
#endif

	return MSM_RESULT_SUCCESS;
}

void *msm_memory_alloc(unsigned int size)
{
#if defined(OSTYPE_LINUX)
	return malloc((size_t)size);
#elif defined(OSTYPE_FREERTOS)
	return pvPortMalloc( (size_t)size );
#else
	///TODO
#endif
}

void *msm_memory_calloc(size_t n, size_t size)
{
#if defined(OSTYPE_LINUX)
	return calloc(n, size);
#elif defined(OSTYPE_FREERTOS)
	void *p_buf = NULL;

	p_buf = msm_memory_alloc(n * size);
	//assert
	if(p_buf)
	{
		memset(p_buf, 0, n * size);
	}

	return p_buf;
#else
	///TODO
#endif
}

void msm_memory_free (void *pmem)
{
	if(pmem)
	{
	#if defined(OSTYPE_LINUX)
		free(pmem);
	#elif defined(OSTYPE_FREERTOS)
		vPortFree( pmem );
	#else
	///TODO
	#endif
	}
}

uint16_t msm_htons(uint16_t n)
{
	#if defined(OSTYPE_LINUX) || defined(OSTYPE_FREERTOS)
	return htons(n);
	#else
	///TODO
	#endif
}

uint16_t msm_ntohs(uint16_t n)
{
	#if defined(OSTYPE_LINUX) || defined(OSTYPE_FREERTOS)
	return ntohs(n);
	#else
	///TODO
	#endif
}

uint32_t msm_inet_addr(const char *cp)
{
	#if defined(OSTYPE_LINUX) || defined(OSTYPE_FREERTOS)
	return inet_addr(cp);
	#else
	///TODO
	#endif
}

void msm_fd_set_init(void)
{
	memset(&fd_set_val, 0, sizeof(fd_set_val));
}

void	msm_fd_zero(void)
{
	#if defined(OSTYPE_LINUX) || defined(OSTYPE_FREERTOS)
	FD_ZERO(&fd_set_val);
	#else
	///TODO
	#endif
}

void msm_fd_set(int fd)
{
	#if defined(OSTYPE_LINUX) || defined(OSTYPE_FREERTOS)
	FD_SET(fd, &fd_set_val);
	#else
	///TODO
	#endif
}

int msm_fd_is_set(int fd)
{
	#if defined(OSTYPE_LINUX) || defined(OSTYPE_FREERTOS)
	return FD_ISSET(fd, &fd_set_val);
	#else
	///TODO
	#endif
}

int msm_select(int maxfdp1, uint32_t timeout_ms)
{
	#if defined(OSTYPE_LINUX) || defined(OSTYPE_FREERTOS)
	struct timeval ms_timeout;

	ms_timeout.tv_sec = timeout_ms/1000;
	ms_timeout.tv_usec = (timeout_ms%1000)*1000;

	return select(maxfdp1, &fd_set_val, NULL, NULL, &ms_timeout);
	#else
	///TODO
	#endif
}

int msm_accept(int s, char* rip, unsigned short riplen)
{
	int ret = -1;

	#if defined(OSTYPE_LINUX) || defined(OSTYPE_FREERTOS)
	struct sockaddr_in socket_addr;
	socklen_t len = sizeof(struct sockaddr_in);

	ret = accept(s, (struct sockaddr *)&socket_addr, &len);
	if(ret >= 0)
	{
		strncpy(rip, inet_ntoa(socket_addr.sin_addr), riplen);
		msm_printf("%s %s\r\n", __FUNCTION__, rip);
	}
	#else
	///TODO
	#endif

	return ret;
}

int msm_socket_set_rcvtimeo(int s, unsigned int ms)
{
	int ret = -1;

#if defined(OSTYPE_LINUX)
	struct timeval timeout;
	timeout.tv_sec = ms/1000;
	timeout.tv_usec = (ms%1000) * 1000;

	if((ret = setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout))) < 0)
	{
		MS_ERR_TRACE("setsockopt fail");
		return -1;
	}

#elif defined(OSTYPE_FREERTOS)
#if defined(LWIP_SO_SNDRCVTIMEO_NONSTANDARD) && (LWIP_SO_SNDRCVTIMEO_NONSTANDARD == 0)	// lwip 1.5.0
	struct timeval timeout;
#else
	unsigned int tm_ms = ms;
#endif

#if defined(LWIP_SO_SNDRCVTIMEO_NONSTANDARD) && (LWIP_SO_SNDRCVTIMEO_NONSTANDARD == 0)	// lwip 1.5.0
	timeout.tv_sec = ms/1000;
	timeout.tv_usec = (ms%1000) * 1000;

	if((ret = setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout))) < 0)
#else
	if((ret = setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tm_ms, sizeof(tm_ms))) < 0)
#endif
	{
		MS_ERR_TRACE("setsockopt fail");
		return -1;
	}

#else
	///TODO
#endif

	return ret;
}

int msm_socket_tcp_server_init(int32_t ip, int16_t port, int ms)
{
	int fd = -1, ret;
	int flag = 1;
	struct sockaddr_in sock_addr;

#if defined(OSTYPE_LINUX)
	struct timeval timeout;
#elif defined(OSTYPE_FREERTOS)
#if defined(LWIP_SO_SNDRCVTIMEO_NONSTANDARD) && (LWIP_SO_SNDRCVTIMEO_NONSTANDARD == 0)	// lwip 1.5.0
	struct timeval timeout;
#endif
#else
	///TODO
#endif

	memset(&sock_addr, 0, sizeof(sock_addr));
	sock_addr.sin_family = AF_INET;
	sock_addr.sin_addr.s_addr = htonl(ip);
	sock_addr.sin_port = htons(port);

	fd = socket(AF_INET, SOCK_STREAM, 0);
	if(fd < 0)
	{
		MS_ERR_TRACE("socket %s", strerror(errno));
		goto on_fail;
	}

	ret = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &flag, sizeof(flag));
	if(ret < 0)
	{
		MS_ERR_TRACE("setsockopt %s", strerror(errno));
		goto on_fail;
	}

#if defined(OSTYPE_LINUX)
	timeout.tv_sec = ms/1000;
	timeout.tv_usec = (ms%1000) * 1000;
	ret = setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));

#elif defined(OSTYPE_FREERTOS)
#if defined(LWIP_SO_SNDRCVTIMEO_NONSTANDARD) && (LWIP_SO_SNDRCVTIMEO_NONSTANDARD == 0)	// lwip 1.5.0
	timeout.tv_sec = ms/1000;
	timeout.tv_usec = (ms%1000) * 1000;
	ret = setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));
#else
	ret = setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &ms, sizeof(ms));
#endif

#else
	///TODO
#endif
	if(ret < 0)
	{
		MS_ERR_TRACE("setsockopt %s", strerror(errno));
		goto on_fail;
	}

	ret = bind(fd, (struct sockaddr *)&sock_addr, sizeof(sock_addr));
	if(ret < 0)
	{
		MS_ERR_TRACE("bind %s", strerror(errno));
		goto on_fail;
	}

	listen(fd, 0);

	return fd;

on_fail:
	if(fd >= 0)
	{
		close(fd);
		fd = -1;
	}

	return fd;
}

//socket
int msm_socket_tcp_read(int socket,unsigned char* buffer, int len,int timeout_ms)
{
#if defined(OSTYPE_LINUX)
	struct timeval interval = {timeout_ms / 1000, (timeout_ms % 1000) * 1000};
	if (interval.tv_sec < 0 || (interval.tv_sec == 0 && interval.tv_usec <= 0))
	{
		interval.tv_sec = 0;
		interval.tv_usec = 100;
	}

	setsockopt(socket, SOL_SOCKET, SO_RCVTIMEO, (char *)&interval, sizeof(struct timeval));

#elif defined(OSTYPE_FREERTOS)
#if defined(LWIP_SO_SNDRCVTIMEO_NONSTANDARD) && (LWIP_SO_SNDRCVTIMEO_NONSTANDARD == 0)	// lwip 1.5.0
	struct timeval interval = {timeout_ms / 1000, (timeout_ms % 1000) * 1000};
	if (interval.tv_sec < 0 || (interval.tv_sec == 0 && interval.tv_usec <= 0))
	{
		interval.tv_sec = 0;
		interval.tv_usec = 100;
	}

	setsockopt(socket, SOL_SOCKET, SO_RCVTIMEO, (char *)&interval, sizeof(struct timeval));
#else	// lwip 1.4.1
	setsockopt(socket, SOL_SOCKET, SO_RCVTIMEO, &timeout_ms, sizeof(timeout_ms));
#endif

#else
	///TODO
#endif
	int rc = recv(socket, buffer, (size_t)(len), 0);

#ifdef TCP_DBG
	TRACE("msm_socket_tcp_read:");
	PRINT_BUF(buffer, rc);
#endif
    return rc;
}

int msm_socket_tcp_write(int socket,unsigned char* buffer, int len,int timeout_ms)
{
	int	rc = write(socket, buffer, len);
#ifdef TCP_DBG
	TRACE("ms_socket_write:");
	PRINT_BUF(buffer, rc);
#endif
	return rc;
}

int msm_socket_close(int fd)
{
	return close(fd);
}

int msm_socket_udp_init(unsigned int ip, unsigned short port, int ms, bool broadcast_flag)
{
	int fd = -1, ret = -1;
	int flag = 1, len = sizeof(int);
	struct sockaddr_in sock_addr;

#if defined(OSTYPE_LINUX)
	struct timeval timeout;

#elif defined(OSTYPE_FREERTOS)
#if defined(LWIP_SO_SNDRCVTIMEO_NONSTANDARD) && (LWIP_SO_SNDRCVTIMEO_NONSTANDARD == 0)	// lwip 1.5.0
	struct timeval timeout;
#endif

#else
	///TODO
#endif

	memset(&sock_addr, 0, sizeof(sock_addr));
	sock_addr.sin_family = AF_INET;
	sock_addr.sin_addr.s_addr = htonl(ip);
	sock_addr.sin_port = htons(port);

	fd = socket(AF_INET, SOCK_DGRAM, 0);
	if(fd < 0)
	{
		goto on_fail;
	}

	if(!broadcast_flag)
	{
#if defined(OSTYPE_LINUX)
		timeout.tv_sec = ms/1000;
		timeout.tv_usec = (ms%1000) * 1000;
		ret = setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));

#elif defined(OSTYPE_FREERTOS)
#if defined(LWIP_SO_SNDRCVTIMEO_NONSTANDARD) && (LWIP_SO_SNDRCVTIMEO_NONSTANDARD == 0)	// lwip 1.5.0
		timeout.tv_sec = ms/1000;
		timeout.tv_usec = (ms%1000) * 1000;
		ret = setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));
#else
		ret = setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &ms, sizeof(ms));
#endif

#else
	///TODO
#endif
		if(ret < 0)
		{
			MS_ERR_TRACE("setsockopt %s", strerror(errno));//debugbyyip
			goto on_fail;
		}

		ret = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &flag, len);
		if(ret < 0)
		{
			MS_ERR_TRACE("setsockopt %s", strerror(errno));
			goto on_fail;
		}
#ifdef XR871
		ret = setsockopt(fd, SOL_SOCKET, SO_BROADCAST, &flag, len);
		if(ret < 0)
		{
			MS_ERR_TRACE("setsockopt %s", strerror(errno));
			goto on_fail;
		}
#endif
		ret = bind(fd, (struct sockaddr *)&sock_addr, sizeof(sock_addr));
		if(ret < 0)
		{
			MS_ERR_TRACE("bind %s", strerror(errno));
			goto on_fail;
		}

		//#if defined(MS_DEBUG)
		MS_TRACE("recv udp fd: %d", fd);
		//#endif
	}
	else
	{
		int on = 1;
		ret = setsockopt(fd, SOL_SOCKET, SO_BROADCAST, (void *)&on, sizeof(int));
		if(ret < 0)
		{
			MS_ERR_TRACE("setsockopt %s", strerror(errno));
			goto on_fail;
		}

		//#if defined(MS_DEBUG)
		MS_TRACE("broadcast udp fd: %d", fd);
		//#endif
	}

	return fd;

on_fail:
	if(fd >= 0)
	{
		close(fd);
		fd = -1;
	}
	return fd;
}


int msm_socket_udp_readfrom(int fd, unsigned char* buf, unsigned short len,
        char* rip, unsigned short riplen, unsigned short* rport)
{
	int rc;
	struct sockaddr_in dstaddr;
	socklen_t addrlen = sizeof(dstaddr);

	if(buf == NULL || rip == NULL || rport == NULL)
	{
		return -1;
	}

	rc = recvfrom(fd, buf, len, 0, (struct sockaddr *)&dstaddr, &addrlen);
	if(rc > 0)
	{
		strncpy(rip, inet_ntoa(dstaddr.sin_addr), riplen);
		*rport = ntohs(dstaddr.sin_port);
#ifdef UDP_DBG
		TRACE("msm_socket_udp_readfrom from remote ip:%s, port:%u", rip, *rport);
		TRACE("msm_socket_udp_readfrom:");
		PRINT_BUF(buf, rc);
#endif
	}
	return rc;
}

int msm_socket_udp_writeto(int fd, const unsigned char* buf, unsigned short len,
        const char* rip, unsigned short rport)
{
#ifdef UDP_DBG
	TRACE("msm_socket_udp_writeto:");
	PRINT_BUF(buf, len);
#endif
	struct sockaddr_in dstaddr;

	CLR_STRUCT(&dstaddr);
	dstaddr.sin_family = AF_INET;
	dstaddr.sin_addr.s_addr = inet_addr(rip);
	dstaddr.sin_port = htons(rport);

	return sendto(fd , buf, len, 0, (struct sockaddr *)&dstaddr, sizeof(dstaddr));
}

int msm_socket_open(int *socket_fd, int port,char* addr, int *p_server_ip){
	int fd;
	int type = SOCK_STREAM;
	struct sockaddr_in address;
	int rc = -1;
	int family = AF_INET;
	struct addrinfo *result = NULL;
	struct addrinfo hints = {0, AF_UNSPEC, SOCK_STREAM, IPPROTO_TCP, 0, NULL, NULL, NULL};

	MS_TRACE("start ms dns...");
	printf("start ms dns...\n");
	if ((rc = getaddrinfo(addr, NULL, &hints, &result)) == 0)
	{
		struct addrinfo* res = result;

		/* prefer ip4 addresses */
		while (res)
		{
			if (res->ai_family == AF_INET)
			{
				result = res;
				break;
			}
			res = res->ai_next;
		}

		if (result->ai_family == AF_INET)
		{
			address.sin_port = htons(port);
			address.sin_family = family = AF_INET;
			address.sin_addr = ((struct sockaddr_in*)(result->ai_addr))->sin_addr;
		}
		else
			rc = -1;

		freeaddrinfo(result);
	}

	if (rc == 0)
	{
		MS_TRACE("ms dns ok");
		printf("ms dns ok\n");
		fd = socket(family, type, 0);
		if (fd != -1)
		{
			*p_server_ip = address.sin_addr.s_addr;

			MS_TRACE("ms connecting...");
			printf("ms connecting...\n");
			rc = connect(fd, (struct sockaddr*)&address, sizeof(address));
			if(0 == rc)
			{
				int send_timeout = 3000;

				//MS_TRACE("connected %s[%s], %d, ip:0x%08x", inet_ntoa(address.sin_addr), addr, rc, *p_server_ip);
				printf("connected %s[%s], %d, ip:0x%08x\n", inet_ntoa(address.sin_addr), addr, rc, *p_server_ip);

				#if defined(OSTYPE_LINUX)
				struct timeval timeout;
				timeout.tv_sec = send_timeout/1000;
				timeout.tv_usec = (send_timeout%1000) * 1000;
				rc = setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(timeout));

				#elif defined(OSTYPE_FREERTOS)
				#if defined(LWIP_SO_SNDRCVTIMEO_NONSTANDARD) && (LWIP_SO_SNDRCVTIMEO_NONSTANDARD == 0)	// lwip 1.5.0
				struct timeval timeout;
				timeout.tv_sec = send_timeout/1000;
				timeout.tv_usec = (send_timeout%1000) * 1000;
				rc = setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(timeout));
				#else
				rc = setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, &send_timeout, sizeof(send_timeout));
				#endif

				#else
				///TODO
				#endif
				if(rc < 0)
				{
					MS_ERR_TRACE("setsockopt sndtimeo err");
					printf("setsockopt sndtimeo err\n");
				}
				else
				{
					//TRACE("setsockopt sndtimeo ok");
					*socket_fd = fd;
				}
			}
			else
			{
				MS_TRACE("unconnected %s[%s], %d, ip:0x%08x", inet_ntoa(address.sin_addr), addr, rc, *p_server_ip);
				close(fd);
			}
		}
		else
		{
			MS_ERR_TRACE("socket fail");
		}
	}

	return rc;
}

//sniffer
msm_result_t msm_sniffer_set_chn(int chn)
{
#if defined(OSTYPE_LINUX)
	///TODO
	return MSM_RESULT_SUCCESS;

#elif defined(CHIP_PLATFORM_REALTEK_8710BN)
	return ms_hal_sniffer_set_chn(chn);

#else
	///TODO
	return MSM_RESULT_SUCCESS;

#endif
}

//if platform not support , the return 0; else, return the fixed channel
int msm_sniffer_get_fixed_channel(void *fixed_bssid, unsigned char *ssid, int *ssid_length)
{
#if defined(OSTYPE_LINUX)
	///TODO
	return 0;

#elif defined(CHIP_PLATFORM_REALTEK_8710BN)
	return promisc_get_fixed_channel(fixed_bssid, ssid, ssid_length);
#else
	///TODO
	return 0;

#endif
}

void msm_get_module_version(unsigned char *p_in, int len)
{
	unsigned char ver[6] = {0};

	///TODO
	ver[0] = 0x51;
	ver[1] = 0x00;
	//...

	memcpy(p_in, ver, sizeof(ver));
}

int ms_hal_read_msmart_config_info(const char *path, uint8_t *buf,int len){
    int fd = -1;
	int ret = 0;

	fd = open(path, O_RDONLY);
	if(-1 == fd){
		printf("open fail\r\n");
		close(fd);
		return -1;
	}
	ret = read(fd, buf, len);

	if (ret < 0){
		printf("read fail\r\n");
		close(fd);
		return -1;
	}
	else{
		printf("read %d bytes\r\n", ret);
	}

	close(fd);
	return ret;
}


hexchar2bin(char hexchar)
{
    //printf("hexchar:%c\n", hexchar);
    #if 0 //delete by 926 @20190625
    hexchar = _toupper(hexchar);
    if(hexchar >= 'A'){
        return hexchar - 'A' + 0x0A;
    }else{
        return hexchar - '0';
    }
    #else
    /*
    if (hexchar >= 'a' && hexchar <= 'f')
        return (hexchar - 'a' + 0x0A);
    if (hexchar >= 'A' && hexchar <= 'F')
        return (hexchar - 'A' + 0x0A);
    */
    if (hexchar >= '0' && hexchar <= '9')
        return (hexchar - '0');
    else {
        hexchar = _toupper(hexchar);
        if(hexchar >= 'A'){
            return hexchar - 'A' + 0x0A;
        }else{
            return hexchar - '0';
        }
    }
    #endif
}
status_t ms_hal_wlan_get_mac_address(uint8_t* macbuf)
{
    int i, bytes;
    char buf[200];
    char* substr;
    sprintf(buf, "ifconfig %s", MS_STA_POINT);
    bytes = shell_exec(buf, buf, sizeof(buf));
    //printf("buf:%s\n", buf);
    if (bytes > 0 && (substr=strstr(buf,"HWaddr "))){
        //printf("1substr:%s\n", substr);
        substr += 7;
        //printf("2substr:%s\n", substr);
        printf("get mac:");
        for (i=0; i<6; i++){
            macbuf[i] = (hexchar2bin(*substr) << 4) | hexchar2bin(*(substr+1));
            //printf("hexchar2bin(*substr:%#02x)\n", hexchar2bin(*substr));
            //printf("hexchar2bin(*(substr+1):%#02x)\n", hexchar2bin(*(substr+1)));
            substr += 3;
            printf("%#02x ", macbuf[i]); //add by 926 @20190625
        }
        printf("\n"); //add by 926 @20190625
    }else{
	return ERROR;
    }
    return OK;
}

int ms_hal_getWifiSignal(char * SSID){
    int signal = 0, bytes;
    unsigned char tmp = 0;
    char buf[200];
    char result[6];
    sprintf(buf, "wpa_cli scan_r | awk '($5==\"%s\"){ print $3}'", SSID);
    bytes = shell_exec(buf,result,sizeof(result));
    result[bytes] = 0;
    for(int i=1;i<bytes;i++){
        if((result[i]>='0')&&(result[i]<='9')){
            signal = signal*10;
            signal = signal + (int)(result[i]-'0');
        }
    }
    if(signal>120){
	signal = 0;
    }else{
	signal = (4-signal/30);
    }
    return signal;
}

int ms_hal_getIpAddr(uint8_t* ipbuf, const char* point)
{
    int i = 0, bytes;
    unsigned char tmp = 0;
    char buf[200];
    char* substr;
    sprintf(buf, "ifconfig %s", point);
    bytes = shell_exec(buf, buf, sizeof(buf));
    if (bytes > 0 && (substr=strstr(buf,"inet addr:"))){
        substr += 10;
        while(i<4){
            if (*substr >= '0' && *substr <= '9') {
                tmp = tmp * 10 + (*substr) - '0';
            } else {
                ipbuf[3-i] = tmp;
                i++;
                if (!*substr)
                    break;
                tmp = 0;
            }
            substr++;
        }
        if (i == 4 && ipbuf[2] == 254 && ipbuf[3] == 169){
            return 0;
        }
	return 1;
    }

    return 0;
}

/**
 * @brief 瀛樺偍閰嶇綉淇℃伅鍑芥暟
 * @param path 瀛樺偍璺緞
 * @param buf 瀛樺偍鐨勬秷鎭綋
 * @param len 瀛樺偍娑堟伅鐨勯暱搴�
 * @return >=0 瀛樺偍鎴愬姛
 *		   -1 瀛樺偍澶辫触
 * @note
 * 姝ゅ灏嗕俊鎭瓨鍌ㄤ簬ms_stored_info.txt鏂囦欢涓�
 */
int msm_write_config(const char * path, char *buf, int len)
{
	int fd = -1;
	int ret;
	/*Write I/O operations on the file descriptor shall
	complete as defined by synchronized I/O file integrity completion. */
	fd = open(path, O_CREAT|O_WRONLY | O_SYNC, 0777);
	if(-1 == fd)
	{
		MS_ERR_TRACE(" File:%s open fail\r\n,path");
		return -1;
	}

	ret = write(fd, buf, len);
	if (ret < 0)
	{
		MS_ERR_TRACE("File:%s write fail\r\n",path);
		close(fd);
		return -1;
	}
	else
	{
		MS_TRACE("File:%s write %d bytes\r\n", path,ret);
	}

	close(fd);

	return ret;
}

/**
 * @brief 璇诲彇閰嶇綉淇℃伅鍑芥暟
 * @param path 璇诲彇璺緞
 * @param buf 璇诲彇缂撳瓨
 * @param len 璇诲彇闀垮害
 * @return >=0 璇诲彇鎴愬姛
 *		   -1  璇诲彇澶辫触
 */
int msm_read_config(const char * path, char *buf, int len)
{
	int fd = -1;
	int ret;

	fd = open(path, O_RDONLY);
	if(-1 == fd)
	{
		printf("open fail\r\n");
		return -1;
	}
	ret = read(fd, buf, len);
	if (ret < 0)
	{
		printf("read fail\r\n");
		close(fd);
		return -1;
	}
	else
	{
		printf("read %d bytes\r\n", ret);
	}

	close(fd);

	return ret;
}

int shell_exec(const char* exe, char* buf, int len)
{
    FILE* stream;
    int res = 0;
    stream = popen(exe, "r");
    if (!stream) return res;
    if (buf != NULL){
        res = fread(buf, sizeof(char), len, stream);
    }
    pclose(stream);
    return res;
}
int get_wifi_signal(const char *ssid){
    int signal;
    int size;
	system("wpa_cli scan; sleep 1");
    char str[128] = "wpa_cli scan_r | sort -k 3 | grep %s -w | awk 'NR==1 {print $3}'";
	char cmd[128] = "wpa_cli scan_r | sort -k 3 | awk 'NR==3 {print $3}'";
	if (ssid){
		sprintf(cmd, str, ssid);
	}
    char buf[5];
    int i;
    size=shell_exec(cmd,buf,5);
    buf[size-1] = 0;
    sscanf(buf,"-%d",&signal);
    printf("signal:%d\n",signal);
    return signal;
}

int write_state_to_uart_fifo(char *path,T_MsTransStream *tframe){
    int fd_wr;
    int ret;
    if(-1==(fd_wr = open(path,  O_WRONLY | O_NONBLOCK))){
	MS_ERR_TRACE("NET Process open %s fail",path);
    }
    // Read from FIFO
    if((ret=write(fd_wr, tframe, sizeof(T_MsTransStream)))<=0){
	MS_ERR_TRACE("NET Process write %s fail",path);
    }
    close(fd_wr);
    return ret;
}

int system_state_change(char *path,ms_sys_status_t *sys_state){

    T_MsTransStream tframe;
    int ret = 0;
    memset(&tframe,0,sizeof(tframe));
    if(-1 == (ret =msm_write_config(MS_SYS_STATUS_PATH, sys_state, sizeof(*sys_state))))
    {
        MS_TRACE("stored info fail");
        return ret;
    }
    tframe.event = MS_SYS_EVENT_SYS_STATUS_CHANGED;
    ret = write_state_to_uart_fifo(path, &tframe);

    return ret;
}

#ifdef HARD_VAD
int init_wakelock_client(){
    int socket_cli;
    struct sockaddr_in address;
    bzero(&address, sizeof(address));
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = inet_addr("127.0.0.1");
    address.sin_port = htons(MS_UDP_WAKEUP_PORT);
    socket_cli = socket(AF_INET, SOCK_DGRAM, 0);
    if(socket_cli <= 0){
	MS_TRACE("Create socket_cli error:%s",strerror(errno));
	return -1;
    }
    return socket_cli;
}
int ms_sent_wakelock_event(int fd,E_MsDownStream event){

	struct sockaddr_in address;
	bzero(&address, sizeof(address));
	address.sin_family = AF_INET;
    address.sin_addr.s_addr = inet_addr("127.0.0.1");
	address.sin_port = htons(MS_UDP_WAKEUP_PORT);
	if(sendto(fd, &event, sizeof(event), 0, (struct sockaddr*)&address, sizeof(address))<=0){
		MS_TRACE("Send wakelock error:%s",strerror(errno));
        return -1;
	}
    return 0 ;
}
void close_wakelock_client(int fd){
	if(fd>0)
		close(fd);
}
#endif
